

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nghttp2.h &mdash; nghttp2 1.22.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="nghttp2 1.22.0 documentation" href="index.html"/>
        <link rel="next" title="nghttp2ver.h" href="nghttp2ver.h.html"/>
        <link rel="prev" title="Python API Reference" href="python-apiref.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> nghttp2
          

          
          </a>

          
            
            
              <div class="version">
                1.22.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="package_README.html">nghttp2 - HTTP/2 C Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-android-binary.html">Building Android binary</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-client.html">Tutorial: HTTP/2 client</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-server.html">Tutorial: HTTP/2 server</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-hpack.html">Tutorial: HPACK API</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp.1.html">nghttp(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpd.1.html">nghttpd(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx.1.html">nghttpx(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="h2load.1.html">h2load(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx-howto.html">nghttpx - HTTP/2 proxy - HOW-TO</a></li>
<li class="toctree-l1"><a class="reference internal" href="h2load-howto.html">h2load - HTTP/2 benchmarking tool - HOW-TO</a></li>
<li class="toctree-l1"><a class="reference internal" href="programmers-guide.html">Programmers' Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="libnghttp2_asio.html">libnghttp2_asio: High level HTTP/2 C++ library</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-apiref.html">Python API Reference</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">nghttp2.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp2ver.h.html">nghttp2ver.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_server.h.html">asio_http2_server.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_client.h.html">asio_http2_client.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2.h.html">asio_http2.h</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nghttp2/nghttp2">Source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nghttp2/nghttp2/issues">Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://nghttp2.org/">nghttp2.org</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">nghttp2</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>nghttp2.h</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nghttp2-h">
<h1>nghttp2.h<a class="headerlink" href="#nghttp2-h" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * nghttp2 - HTTP/2 C Library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2013, 2014 Tatsuhiro Tsujikawa</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="cm"> * a copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NGHTTP2_H</span>
<span class="cp">#define NGHTTP2_H</span>

<span class="cm">/* Define WIN32 when build target is Win32 API (borrowed from</span>
<span class="cm">   libcurl) */</span>
<span class="cp">#if (defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(WIN32)</span>
<span class="cp">#define WIN32</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1800)</span>
<span class="cm">/* MSVC &lt; 2013 does not have inttypes.h because it is not C99</span>
<span class="cm">   compliant.  See compiler macros and version number in</span>
<span class="cm">   https://sourceforge.net/p/predef/wiki/Compilers/ */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#else </span><span class="cm">/* !defined(_MSC_VER) || (_MSC_VER &gt;= 1800) */</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* !defined(_MSC_VER) || (_MSC_VER &gt;= 1800) */</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;nghttp2/nghttp2ver.h&gt;</span><span class="cp"></span>

<span class="cp">#ifdef NGHTTP2_STATICLIB</span>
<span class="cp">#define NGHTTP2_EXTERN</span>
<span class="cp">#elif defined(WIN32)</span>
<span class="cp">#ifdef BUILDING_NGHTTP2</span>
<span class="cp">#define NGHTTP2_EXTERN __declspec(dllexport)</span>
<span class="cp">#else </span><span class="cm">/* !BUILDING_NGHTTP2 */</span><span class="cp"></span>
<span class="cp">#define NGHTTP2_EXTERN __declspec(dllimport)</span>
<span class="cp">#endif </span><span class="cm">/* !BUILDING_NGHTTP2 */</span><span class="cp"></span>
<span class="cp">#else  </span><span class="cm">/* !defined(WIN32) */</span><span class="cp"></span>
<span class="cp">#ifdef BUILDING_NGHTTP2</span>
<span class="cp">#define NGHTTP2_EXTERN __attribute__((visibility(&quot;default&quot;)))</span>
<span class="cp">#else </span><span class="cm">/* !BUILDING_NGHTTP2 */</span><span class="cp"></span>
<span class="cp">#define NGHTTP2_EXTERN</span>
<span class="cp">#endif </span><span class="cm">/* !BUILDING_NGHTTP2 */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* !defined(WIN32) */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over TLS.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID &quot;h2&quot;</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID_LEN 2</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The serialized form of ALPN protocol identifier this library</span>
<span class="cm"> * supports.  Notice that first byte is the length of following</span>
<span class="cm"> * protocol identifier.  This is the same wire format of `TLS ALPN</span>
<span class="cm"> * extension &lt;https://tools.ietf.org/html/rfc7301&gt;`_.  This is useful</span>
<span class="cm"> * to process incoming ALPN tokens in wire format.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_ALPN &quot;\x2h2&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_PROTO_ALPN`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_ALPN_LEN (sizeof(NGHTTP2_PROTO_ALPN) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over cleartext</span>
<span class="cm"> * TCP.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID &quot;h2c&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLEARTEXT_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID_LEN 3</span>

<span class="k">struct</span> <span class="n">nghttp2_session</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The primary structure to hold the resources needed for a HTTP/2</span>
<span class="cm"> * session.  The details of this structure are intentionally hidden</span>
<span class="cm"> * from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_session</span> <span class="n">nghttp2_session</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The age of :type:`nghttp2_info`</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_VERSION_AGE 1</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is what `nghttp2_version()` returns.  It holds</span>
<span class="cm"> * information about the particular nghttp2 version.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Age of this struct.  This instance of nghttp2 sets it to</span>
<span class="cm">   * :macro:`NGHTTP2_VERSION_AGE` but a future version may bump it and</span>
<span class="cm">   * add more struct fields at the bottom</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * the :macro:`NGHTTP2_VERSION_NUM` number (since age ==1)</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">version_num</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_VERSION` string (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version_str</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_PROTO_VERSION_ID` string this</span>
<span class="cm">   * instance implements (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">proto_str</span><span class="p">;</span>
  <span class="cm">/* -------- the above fields all exist when age == 1 */</span>
<span class="p">}</span> <span class="n">nghttp2_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The default weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_DEFAULT_WEIGHT 16</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WEIGHT 256</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The minimum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MIN_WEIGHT 1</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum window size</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WINDOW_SIZE ((int32_t)((1U &lt;&lt; 31) - 1))</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for stream level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for connection level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The default header table size.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_DEFAULT_HEADER_TABLE_SIZE (1 &lt;&lt; 12)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The client magic string, which is the first 24 bytes byte string of</span>
<span class="cm"> * client connection preface.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_MAGIC &quot;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLIENT_MAGIC`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_MAGIC_LEN 24</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * Error codes used in this library.  The code range is [-999, -500],</span>
<span class="cm"> * inclusive. The following values are defined:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid argument passed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_ARGUMENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">501</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Out of buffer space.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_BUFFER_ERROR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">502</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The specified protocol version is not supported.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_UNSUPPORTED_VERSION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">503</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from :type:`nghttp2_send_callback`,</span>
<span class="cm">   * :type:`nghttp2_recv_callback` and</span>
<span class="cm">   * :type:`nghttp2_send_data_callback` to indicate that the operation</span>
<span class="cm">   * would block.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_WOULDBLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">504</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * General protocol error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PROTO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">505</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_FRAME</span> <span class="o">=</span> <span class="o">-</span><span class="mi">506</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The peer performed a shutdown on the connection.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">507</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` to indicate that data</span>
<span class="cm">   * transfer is postponed.  See</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` for details.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">508</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Stream ID has reached the maximum value.  Therefore no stream ID</span>
<span class="cm">   * is available.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">509</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream is already closed; or the stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">510</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * RST_STREAM has been added to the outbound queue.  The stream is</span>
<span class="cm">   * in closing state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">511</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The transmission is not allowed for this stream (e.g., a frame</span>
<span class="cm">   * with END_STREAM flag set has already sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_SHUT_WR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">512</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_ID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">513</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The state of the stream is not valid (e.g., DATA cannot be sent</span>
<span class="cm">   * to the stream if response HEADERS has not been sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">514</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Another DATA frame has already been deferred.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">515</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Starting new stream is not allowed (e.g., GOAWAY has been sent</span>
<span class="cm">   * and/or received).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_START_STREAM_NOT_ALLOWED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">516</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * GOAWAY has already been sent.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_GOAWAY_ALREADY_SENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">517</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The received frame contains the invalid header block (e.g., There</span>
<span class="cm">   * are duplicate header names; or the header names are not encoded</span>
<span class="cm">   * in US-ASCII character set and not lower cased; or the header name</span>
<span class="cm">   * is zero-length string; or the header value contains multiple</span>
<span class="cm">   * in-sequence NUL bytes).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_HEADER_BLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">518</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that the context is not suitable to perform the</span>
<span class="cm">   * requested operation.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">519</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed due to the temporal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">521</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the frame is invalid, either too large or too small.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">522</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Header block inflate/deflate error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HEADER_COMP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">523</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Flow control error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FLOW_CONTROL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">524</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Insufficient buffer size given to function.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INSUFF_BUFSIZE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">525</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback was paused by the application</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PAUSE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">526</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * There are too many in-flight SETTING frame and no more</span>
<span class="cm">   * transmission of SETTINGS is allowed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">527</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The server push is disabled.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PUSH_DISABLED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">528</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * DATA or HEADERS frame for a given stream has been already</span>
<span class="cm">   * submitted and has not been fully processed yet.  Application</span>
<span class="cm">   * should wait for the transmission of the previously submitted</span>
<span class="cm">   * frame before submitting another.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">529</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The current session is closing due to a connection error or</span>
<span class="cm">   * `nghttp2_session_terminate_session()` is called.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_SESSION_CLOSING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">530</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid HTTP header field was received and stream is going to be</span>
<span class="cm">   * closed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HTTP_HEADER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">531</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Violation in HTTP messaging rule.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HTTP_MESSAGING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">532</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Stream was refused.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_REFUSED_STREAM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">533</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Unexpected internal error, but recovered.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INTERNAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">534</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that a processing was canceled.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_CANCEL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">535</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The errors &lt; :enum:`NGHTTP2_ERR_FATAL` mean that the library is</span>
<span class="cm">   * under unexpected condition and processing was terminated (e.g.,</span>
<span class="cm">   * out of memory).  If application receives this error code, it must</span>
<span class="cm">   * stop using that :type:`nghttp2_session` object and only allowed</span>
<span class="cm">   * operation for that object is deallocate it using</span>
<span class="cm">   * `nghttp2_session_del()`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FATAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Out of memory.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_NOMEM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">901</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">902</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid client magic (see :macro:`NGHTTP2_CLIENT_MAGIC`) was</span>
<span class="cm">   * received and further processing is not possible.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_BAD_CLIENT_MAGIC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">903</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Possible flooding by peer was detected in this HTTP/2 session.</span>
<span class="cm">   * Flooding is measured by how many PING and SETTINGS frames with</span>
<span class="cm">   * ACK flag set are queued for transmission.  These frames are</span>
<span class="cm">   * response for the peer initiated frames, and peer can cause memory</span>
<span class="cm">   * exhaustion on server side to send these frames forever and does</span>
<span class="cm">   * not read network.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FLOODED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">904</span>
<span class="p">}</span> <span class="n">nghttp2_error</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The object representing single contiguous buffer.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_vec</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">nghttp2_rcbuf</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The object representing reference counted buffer.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_rcbuf</span> <span class="n">nghttp2_rcbuf</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Increments the reference count of |rcbuf| by 1.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_rcbuf_incref</span><span class="p">(</span><span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">rcbuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements the reference count of |rcbuf| by 1.  If the reference</span>
<span class="cm"> * count becomes zero, the object pointed by |rcbuf| will be freed.</span>
<span class="cm"> * In this case, application must not use |rcbuf| again.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_rcbuf_decref</span><span class="p">(</span><span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">rcbuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the underlying buffer managed by |rcbuf|.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_vec</span> <span class="nf">nghttp2_rcbuf_get_buf</span><span class="p">(</span><span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">rcbuf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for header field name/value pair.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that this name/value pair must not be indexed (&quot;Literal</span>
<span class="cm">   * Header Field never Indexed&quot; representation must be used in HPACK</span>
<span class="cm">   * encoding).  Other implementation calls this bit as &quot;sensitive&quot;.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NO_INDEX</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * This flag is set solely by application.  If this flag is set, the</span>
<span class="cm">   * library does not make a copy of header field name.  This could</span>
<span class="cm">   * improve performance.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NO_COPY_NAME</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * This flag is set solely by application.  If this flag is set, the</span>
<span class="cm">   * library does not make a copy of header field value.  This could</span>
<span class="cm">   * improve performance.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NO_COPY_VALUE</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="p">}</span> <span class="n">nghttp2_nv_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The name/value pair, which mainly used to represent header fields.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The |name| byte string.  If this struct is presented from library</span>
<span class="cm">   * (e.g., :type:`nghttp2_on_frame_recv_callback`), |name| is</span>
<span class="cm">   * guaranteed to be NULL-terminated.  For some callbacks</span>
<span class="cm">   * (:type:`nghttp2_before_frame_send_callback`,</span>
<span class="cm">   * :type:`nghttp2_on_frame_send_callback`, and</span>
<span class="cm">   * :type:`nghttp2_on_frame_not_send_callback`), it may not be</span>
<span class="cm">   * NULL-terminated if header field is passed from application with</span>
<span class="cm">   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`).  When application</span>
<span class="cm">   * is constructing this struct, |name| is not required to be</span>
<span class="cm">   * NULL-terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The |value| byte string.  If this struct is presented from</span>
<span class="cm">   * library (e.g., :type:`nghttp2_on_frame_recv_callback`), |value|</span>
<span class="cm">   * is guaranteed to be NULL-terminated.  For some callbacks</span>
<span class="cm">   * (:type:`nghttp2_before_frame_send_callback`,</span>
<span class="cm">   * :type:`nghttp2_on_frame_send_callback`, and</span>
<span class="cm">   * :type:`nghttp2_on_frame_not_send_callback`), it may not be</span>
<span class="cm">   * NULL-terminated if header field is passed from application with</span>
<span class="cm">   * the flag :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE`).  When</span>
<span class="cm">   * application is constructing this struct, |value| is not required</span>
<span class="cm">   * to be NULL-terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |name|, excluding terminating NULL.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |value|, excluding terminating NULL.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_nv</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The frame types in HTTP/2 specification.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HEADERS</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PRIORITY</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_RST_STREAM</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PUSH_PROMISE</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PING</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_GOAWAY</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_WINDOW_UPDATE</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The CONTINUATION frame.  This frame type won&#39;t be passed to any</span>
<span class="cm">   * callbacks because the library processes this frame type and its</span>
<span class="cm">   * preceding HEADERS/PUSH_PROMISE as a single frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONTINUATION</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The ALTSVC frame, which is defined in `RFC 7383</span>
<span class="cm">   * &lt;https://tools.ietf.org/html/rfc7838#section-4&gt;`_.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ALTSVC</span> <span class="o">=</span> <span class="mh">0x0a</span>
<span class="p">}</span> <span class="n">nghttp2_frame_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for HTTP/2 frames.  This enum defines all flags for all</span>
<span class="cm"> * frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_STREAM flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_STREAM</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_HEADERS flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_HEADERS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The ACK flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_ACK</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PADDED flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PADDED</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PRIORITY</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="p">}</span> <span class="n">nghttp2_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The SETTINGS ID.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_HEADER_TABLE_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_HEADER_TABLE_SIZE</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_ENABLE_PUSH</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_ENABLE_PUSH</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_CONCURRENT_STREAMS</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_INITIAL_WINDOW_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_FRAME_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_FRAME_SIZE</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_HEADER_LIST_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE</span> <span class="o">=</span> <span class="mh">0x06</span>
<span class="p">}</span> <span class="n">nghttp2_settings_id</span><span class="p">;</span>
<span class="cm">/* Note: If we add SETTINGS, update the capacity of</span>
<span class="cm">   NGHTTP2_INBOUND_NUM_IV as well */</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Deprecated.  The initial max concurrent streams is 0xffffffffu.</span>
<span class="cm"> *</span>
<span class="cm"> * Default maximum number of incoming concurrent streams.  Use</span>
<span class="cm"> * `nghttp2_submit_settings()` with</span>
<span class="cm"> * :enum:`NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS` to change the</span>
<span class="cm"> * maximum number of incoming concurrent streams.</span>
<span class="cm"> *</span>
<span class="cm"> * .. note::</span>
<span class="cm"> *</span>
<span class="cm"> *   The maximum number of outgoing concurrent streams is 100 by</span>
<span class="cm"> *   default.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS ((1U &lt;&lt; 31) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The status codes for the RST_STREAM and GOAWAY frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No errors.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NO_ERROR</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * PROTOCOL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PROTOCOL_ERROR</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INTERNAL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INTERNAL_ERROR</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FLOW_CONTROL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLOW_CONTROL_ERROR</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_TIMEOUT</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_TIMEOUT</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * STREAM_CLOSED</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_CLOSED</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FRAME_SIZE_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * REFUSED_STREAM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_REFUSED_STREAM</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CANCEL</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CANCEL</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * COMPRESSION_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_COMPRESSION_ERROR</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CONNECT_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONNECT_ERROR</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * ENHANCE_YOUR_CALM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ENHANCE_YOUR_CALM</span> <span class="o">=</span> <span class="mh">0x0b</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INADEQUATE_SECURITY</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INADEQUATE_SECURITY</span> <span class="o">=</span> <span class="mh">0x0c</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * HTTP_1_1_REQUIRED</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HTTP_1_1_REQUIRED</span> <span class="o">=</span> <span class="mh">0x0d</span>
<span class="p">}</span> <span class="n">nghttp2_error_code</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> * The frame header.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The length field of this frame, excluding frame header.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream identifier (aka, stream ID)</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The type of this frame.  See `nghttp2_frame_type`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The flags.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit in frame header.  Currently, this is always set to 0</span>
<span class="cm">   * and application should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame_hd</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union represents the some kind of data source passed to</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The integer field, suitable for a file descriptor.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to an arbitrary object.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_source</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags used to set in |data_flags| output parameter in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates EOF was sensed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_EOF</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that END_STREAM flag must not be set even if</span>
<span class="cm">   * NGHTTP2_DATA_FLAG_EOF is set.  Usually this flag is used to send</span>
<span class="cm">   * trailer fields with `nghttp2_submit_request()` or</span>
<span class="cm">   * `nghttp2_submit_response()`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NO_END_STREAM</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that application will send complete DATA frame in</span>
<span class="cm">   * :type:`nghttp2_send_data_callback`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NO_COPY</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="p">}</span> <span class="n">nghttp2_data_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library wants to read data from</span>
<span class="cm"> * the |source|.  The read data is sent in the stream |stream_id|.</span>
<span class="cm"> * The implementation of this function must read at most |length|</span>
<span class="cm"> * bytes of data from |source| (or possibly other places) and store</span>
<span class="cm"> * them in |buf| and return number of data stored in |buf|.  If EOF is</span>
<span class="cm"> * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*data_flags|.</span>
<span class="cm"> *</span>
<span class="cm"> * Sometime it is desirable to avoid copying data into |buf| and let</span>
<span class="cm"> * application to send data directly.  To achieve this, set</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` to |*data_flags| (and possibly</span>
<span class="cm"> * other flags, just like when we do copy), and return the number of</span>
<span class="cm"> * bytes to send without copying data into |buf|.  The library, seeing</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_COPY`, will invoke</span>
<span class="cm"> * :type:`nghttp2_send_data_callback`.  The application must send</span>
<span class="cm"> * complete DATA frame in that callback.</span>
<span class="cm"> *</span>
<span class="cm"> * If this callback is set by `nghttp2_submit_request()`,</span>
<span class="cm"> * `nghttp2_submit_response()` or `nghttp2_submit_headers()` and</span>
<span class="cm"> * `nghttp2_submit_data()` with flag parameter</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_STREAM` set, and</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF` flag is set to |*data_flags|, DATA</span>
<span class="cm"> * frame will have END_STREAM flag set.  Usually, this is expected</span>
<span class="cm"> * behaviour and all are fine.  One exception is send trailer fields.</span>
<span class="cm"> * You cannot send trailer fields after sending frame with END_STREAM</span>
<span class="cm"> * set.  To avoid this problem, one can set</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM` along with</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF` to signal the library not to set</span>
<span class="cm"> * END_STREAM in DATA frame.  Then application can use</span>
<span class="cm"> * `nghttp2_submit_trailer()` to send trailer fields.</span>
<span class="cm"> * `nghttp2_submit_trailer()` can be called inside this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application wants to postpone DATA frames (e.g.,</span>
<span class="cm"> * asynchronous I/O, or reading data blocks for long time), it is</span>
<span class="cm"> * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading</span>
<span class="cm"> * any data in this invocation.  The library removes DATA frame from</span>
<span class="cm"> * the outgoing queue temporarily.  To move back deferred DATA frame</span>
<span class="cm"> * to outgoing queue, call `nghttp2_session_resume_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * By default, |length| is limited to 16KiB at maximum.  If peer</span>
<span class="cm"> * allows larger frames, application can enlarge transmission buffer</span>
<span class="cm"> * size.  See :type:`nghttp2_data_source_read_length_callback` for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application just wants to return from</span>
<span class="cm"> * `nghttp2_session_send()` or `nghttp2_session_mem_send()` without</span>
<span class="cm"> * sending anything, return :enum:`NGHTTP2_ERR_PAUSE`.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of error, there are 2 choices. Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream</span>
<span class="cm"> * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  If a</span>
<span class="cm"> * different error code is desirable, use</span>
<span class="cm"> * `nghttp2_submit_rst_stream()` with a desired error code and then</span>
<span class="cm"> * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_data_source_read_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data_flags</span><span class="p">,</span> <span class="n">nghttp2_data_source</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct represents the data source and the way to read a chunk</span>
<span class="cm"> * of data from it.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The data source.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source</span> <span class="n">source</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The callback function to read a chunk of data from the |source|.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source_read_callback</span> <span class="n">read_callback</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_provider</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The DATA frame.  The received data is delivered via</span>
<span class="cm"> * :type:`nghttp2_on_data_chunk_recv_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The category of HEADERS, which indicates the role of the frame.  In</span>
<span class="cm"> * HTTP/2 spec, request, response, push response and other arbitrary</span>
<span class="cm"> * headers (e.g., trailer fields) are all called just HEADERS.  To</span>
<span class="cm"> * give the application the role of incoming HEADERS frame, we define</span>
<span class="cm"> * several categories.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is opening new stream, which is analogous to</span>
<span class="cm">   * SYN_STREAM in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_REQUEST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first response headers, which is</span>
<span class="cm">   * analogous to SYN_REPLY in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first headers sent against reserved</span>
<span class="cm">   * stream.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_PUSH_RESPONSE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame which does not apply for the above categories,</span>
<span class="cm">   * which is analogous to HEADERS in SPDY.  If non-final response</span>
<span class="cm">   * (e.g., status 1xx) is used, final response HEADERS frame will be</span>
<span class="cm">   * categorized here.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_HEADERS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">nghttp2_headers_category</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The structure to specify stream dependency.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID of the stream to depend on.  Specifying 0 makes</span>
<span class="cm">   * stream not depend any other stream.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The weight of this dependency.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * nonzero means exclusive dependency</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">exclusive</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority_spec</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The HEADERS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The category of this HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers_category</span> <span class="n">cat</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_headers</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PRIORITY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The RST_STREAM frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_rst_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS ID/Value pair.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS ID.  See :type:`nghttp2_settings_id`.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">settings_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The value of this entry.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings_entry</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of SETTINGS ID/Value pairs in |iv|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">niv</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to the array of SETTINGS ID/Value pair.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PUSH_PROMISE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The promised stream ID</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">promised_stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_push_promise</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PING frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The opaque data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">opaque_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">nghttp2_ping</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The GOAWAY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The last stream stream ID.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The additional debug data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |opaque_data| member.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_goaway</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The WINDOW_UPDATE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The window size increment.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Reserved bit.  Currently this is always set to 0 and application</span>
<span class="cm">   * should not expect something useful in here.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_window_update</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The extension frame.  It has following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to extension payload.  The exact pointer type is</span>
<span class="cm">   * determined by hd.type.</span>
<span class="cm">   *</span>
<span class="cm">   * Currently, no extension is supported.  This is a place holder for</span>
<span class="cm">   * the future extensions.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_extension</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union includes all frames to pass them to various function</span>
<span class="cm"> * calls as nghttp2_frame type.  The CONTINUATION frame is omitted</span>
<span class="cm"> * from here because the library deals with it internally.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header, which is convenient to inspect frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data</span> <span class="n">data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers</span> <span class="n">headers</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority</span> <span class="n">priority</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_rst_stream</span> <span class="n">rst_stream</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings</span> <span class="n">settings</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_push_promise</span> <span class="n">push_promise</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_ping</span> <span class="n">ping</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_goaway</span> <span class="n">goaway</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_window_update</span> <span class="n">window_update</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The extension frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_extension</span> <span class="n">ext</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to send data to the</span>
<span class="cm"> * remote peer.  The implementation of this function must send at most</span>
<span class="cm"> * |length| bytes of data stored in |data|.  The |flags| is currently</span>
<span class="cm"> * not used and always 0. It must return the number of bytes sent if</span>
<span class="cm"> * it succeeds.  If it cannot send any single byte without blocking,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_send()` to send data to the remote endpoint.  If</span>
<span class="cm"> * the application uses solely `nghttp2_session_mem_send()` instead,</span>
<span class="cm"> * this callback function is unnecessary.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_send_callback()`.</span>
<span class="cm"> *</span>
<span class="cm"> * .. note::</span>
<span class="cm"> *</span>
<span class="cm"> *   The |length| may be very small.  If that is the case, and</span>
<span class="cm"> *   application disables Nagle algorithm (``TCP_NODELAY``), then just</span>
<span class="cm"> *   writing |data| to the network stack leads to very small packet,</span>
<span class="cm"> *   and it is very inefficient.  An application should be responsible</span>
<span class="cm"> *   to buffer up small chunks of data as necessary to avoid this</span>
<span class="cm"> *   situation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
                                         <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is</span>
<span class="cm"> * used in :type:`nghttp2_data_source_read_callback` to send complete</span>
<span class="cm"> * DATA frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |frame| is a DATA frame to send.  The |framehd| is the</span>
<span class="cm"> * serialized frame header (9 bytes). The |length| is the length of</span>
<span class="cm"> * application data to send (this does not include padding).  The</span>
<span class="cm"> * |source| is the same pointer passed to</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * The application first must send frame header |framehd| of length 9</span>
<span class="cm"> * bytes.  If ``frame-&gt;data.padlen &gt; 0``, send 1 byte of value</span>
<span class="cm"> * ``frame-&gt;data.padlen - 1``.  Then send exactly |length| bytes of</span>
<span class="cm"> * application data.  Finally, if ``frame-&gt;data.padlen &gt; 1``, send</span>
<span class="cm"> * ``frame-&gt;data.padlen - 1`` bytes of zero as padding.</span>
<span class="cm"> *</span>
<span class="cm"> * The application has to send complete DATA frame in this callback.</span>
<span class="cm"> * If all data were written successfully, return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * If it cannot send any data at all, just return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`; the library will call this callback</span>
<span class="cm"> * with the same parameters later (It is recommended to send complete</span>
<span class="cm"> * DATA frame at once in this function to deal with error; if partial</span>
<span class="cm"> * frame data has already sent, it is impossible to send another data</span>
<span class="cm"> * in that state, and all we can do is tear down connection).  When</span>
<span class="cm"> * data is fully processed, but application wants to make</span>
<span class="cm"> * `nghttp2_session_mem_send()` or `nghttp2_session_send()` return</span>
<span class="cm"> * immediately without processing next frames, return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE`.  If application decided to reset this</span>
<span class="cm"> * stream, return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`, then</span>
<span class="cm"> * the library will send RST_STREAM with INTERNAL_ERROR as error code.</span>
<span class="cm"> * The application can also return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, which will result in</span>
<span class="cm"> * connection closure.  Returning any other value is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_send_data_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                          <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">framehd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span>
                                          <span class="n">nghttp2_data_source</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span>
                                          <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to receive data from</span>
<span class="cm"> * the remote peer.  The implementation of this function must read at</span>
<span class="cm"> * most |length| bytes of data and store it in |buf|.  The |flags| is</span>
<span class="cm"> * currently not used and always 0.  It must return the number of</span>
<span class="cm"> * bytes written in |buf| if it succeeds.  If it cannot read any</span>
<span class="cm"> * single byte without blocking, it must return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any</span>
<span class="cm"> * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other</span>
<span class="cm"> * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_recv()` to receive data from the remote endpoint.</span>
<span class="cm"> * If the application uses solely `nghttp2_session_mem_recv()`</span>
<span class="cm"> * instead, this callback function is unnecessary.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
                                         <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` and</span>
<span class="cm"> * `nghttp2_session_mem_recv()` when a frame is received.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.  The header name/value pairs are emitted via</span>
<span class="cm"> * :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be</span>
<span class="cm"> * called after stream is closed (see</span>
<span class="cm"> * :type:`nghttp2_on_stream_close_callback`).  The application should</span>
<span class="cm"> * check that stream is still alive using its own stream management or</span>
<span class="cm"> * :func:`nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Only HEADERS and DATA frame can signal the end of incoming data.</span>
<span class="cm"> * If ``frame-&gt;hd.flags &amp; NGHTTP2_FLAG_END_STREAM`` is nonzero, the</span>
<span class="cm"> * |frame| is the last frame from the remote peer in this stream.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback won&#39;t be called for CONTINUATION frames.</span>
<span class="cm"> * HEADERS/PUSH_PROMISE + CONTINUATIONs are treated as single frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero value is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                              <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` and</span>
<span class="cm"> * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is</span>
<span class="cm"> * received.  The error is indicated by the |lib_error_code|, which is</span>
<span class="cm"> * one of the values defined in :type:`nghttp2_error`.  When this</span>
<span class="cm"> * callback function is invoked, the library automatically submits</span>
<span class="cm"> * either RST_STREAM or GOAWAY frame.  The |user_data| pointer is the</span>
<span class="cm"> * third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_invalid_frame_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_invalid_frame_recv_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a chunk of data in DATA frame is</span>
<span class="cm"> * received.  The |stream_id| is the stream ID this DATA frame belongs</span>
<span class="cm"> * to.  The |flags| is the flags of DATA frame which this data chunk</span>
<span class="cm"> * is contained.  ``(flags &amp; NGHTTP2_FLAG_END_STREAM) != 0`` does not</span>
<span class="cm"> * necessarily mean this chunk of data is the last one in the stream.</span>
<span class="cm"> * You should use :type:`nghttp2_on_frame_recv_callback` to know all</span>
<span class="cm"> * data frames are received.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory by</span>
<span class="cm"> * pointed by the |data| is retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce the |data| parameter, because it may refer to the memory</span>
<span class="cm"> * region included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error, and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_data_chunk_recv_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_data_chunk_recv_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                   <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                                   <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked just before the non-DATA frame |frame| is</span>
<span class="cm"> * sent.  The |user_data| pointer is the third argument passed in to</span>
<span class="cm"> * the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * It can also return :enum:`NGHTTP2_ERR_CANCEL` to cancel the</span>
<span class="cm"> * transmission of the given frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is a fatal error while executing this callback, the</span>
<span class="cm"> * implementation should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`,</span>
<span class="cm"> * which makes `nghttp2_session_send()` and</span>
<span class="cm"> * `nghttp2_session_mem_send()` functions immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the other value is returned, it is treated as if</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.  But the</span>
<span class="cm"> * implementation should not rely on this since the library may define</span>
<span class="cm"> * new return value to extend its capability.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_before_frame_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_before_frame_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                  <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the frame |frame| is sent.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                              <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the non-DATA frame |frame| is not</span>
<span class="cm"> * sent because of the error.  The error is indicated by the</span>
<span class="cm"> * |lib_error_code|, which is one of the values defined in</span>
<span class="cm"> * :type:`nghttp2_error`.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()` can be used to get</span>
<span class="cm"> * associated data.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_frame_not_send_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_not_send_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                  <span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">,</span>
                                                  <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the stream |stream_id| is closed.</span>
<span class="cm"> * The reason of closure is indicated by the |error_code|.  The</span>
<span class="cm"> * |error_code| is usually one of :enum:`nghttp2_error_code`, but that</span>
<span class="cm"> * is not guaranteed.  The stream_user_data, which was specified in</span>
<span class="cm"> * `nghttp2_submit_request()` or `nghttp2_submit_headers()`, is still</span>
<span class="cm"> * available in this function.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is also called for a stream in reserved state.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()`, `nghttp2_session_mem_recv()`,</span>
<span class="cm"> * `nghttp2_session_send()`, and `nghttp2_session_mem_send()`</span>
<span class="cm"> * functions immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_stream_close_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_stream_close_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span>
                                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the reception of header block in</span>
<span class="cm"> * HEADERS or PUSH_PROMISE is started.  Each header name/value pair</span>
<span class="cm"> * will be emitted by :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``frame-&gt;hd.flags`` may not have</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_HEADERS` flag set, which indicates that one</span>
<span class="cm"> * or more CONTINUATION frames are involved.  But the application does</span>
<span class="cm"> * not need to care about that because the header name/value pairs are</span>
<span class="cm"> * emitted transparently regardless of CONTINUATION frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The server applications probably create an object to store</span>
<span class="cm"> * information about new stream if ``frame-&gt;hd.type ==</span>
<span class="cm"> * NGHTTP2_HEADERS`` and ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_REQUEST``.  If |session| is configured as server side,</span>
<span class="cm"> * ``frame-&gt;headers.cat`` is either ``NGHTTP2_HCAT_REQUEST``</span>
<span class="cm"> * containing request headers or ``NGHTTP2_HCAT_HEADERS`` containing</span>
<span class="cm"> * trailer fields and never get PUSH_PROMISE in this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * For the client applications, ``frame-&gt;hd.type`` is either</span>
<span class="cm"> * ``NGHTTP2_HEADERS`` or ``NGHTTP2_PUSH_PROMISE``.  In case of</span>
<span class="cm"> * ``NGHTTP2_HEADERS``, ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_RESPONSE`` means that it is the first response</span>
<span class="cm"> * headers, but it may be non-final response which is indicated by 1xx</span>
<span class="cm"> * status code.  In this case, there may be zero or more HEADERS frame</span>
<span class="cm"> * with ``frame-&gt;headers.cat == NGHTTP2_HCAT_HEADERS`` which has</span>
<span class="cm"> * non-final response code and finally client gets exactly one HEADERS</span>
<span class="cm"> * frame with ``frame-&gt;headers.cat == NGHTTP2_HCAT_HEADERS``</span>
<span class="cm"> * containing final response headers (non-1xx status code).  The</span>
<span class="cm"> * trailer fields also has ``frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_HEADERS`` which does not contain any status code.</span>
<span class="cm"> *</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close</span>
<span class="cm"> * the stream (promised stream if frame is PUSH_PROMISE) by issuing</span>
<span class="cm"> * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,</span>
<span class="cm"> * :type:`nghttp2_on_header_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a</span>
<span class="cm"> * different error code is desirable, use</span>
<span class="cm"> * `nghttp2_submit_rst_stream()` with a desired error code and then</span>
<span class="cm"> * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use</span>
<span class="cm"> * ``frame-&gt;push_promise.promised_stream_id`` as stream_id parameter</span>
<span class="cm"> * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * It can return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` to</span>
<span class="cm"> * reset the stream (promised stream if frame is PUSH_PROMISE).  For</span>
<span class="cm"> * critical errors, it must return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the other value is</span>
<span class="cm"> * returned, it is treated as if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> * is returned.  If :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_mem_recv()` function will immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_begin_headers_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_begin_headers_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a header name/value pair is received</span>
<span class="cm"> * for the |frame|.  The |name| of length |namelen| is header name.</span>
<span class="cm"> * The |value| of length |valuelen| is header value.  The |flags| is</span>
<span class="cm"> * bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm"> *</span>
<span class="cm"> * If :enum:`NGHTTP2_NV_FLAG_NO_INDEX` is set in |flags|, the receiver</span>
<span class="cm"> * must not index this name/value pair when forwarding it to the next</span>
<span class="cm"> * hop.  More specifically, &quot;Literal Header Field never Indexed&quot;</span>
<span class="cm"> * representation must be used in HPACK encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * When this callback is invoked, ``frame-&gt;hd.type`` is either</span>
<span class="cm"> * :enum:`NGHTTP2_HEADERS` or :enum:`NGHTTP2_PUSH_PROMISE`.  After all</span>
<span class="cm"> * header name/value pairs are processed with this callback, and no</span>
<span class="cm"> * error has been detected, :type:`nghttp2_on_frame_recv_callback`</span>
<span class="cm"> * will be invoked.  If there is an error in decompression,</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` for the |frame| will not be</span>
<span class="cm"> * invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * Both |name| and |value| are guaranteed to be NULL-terminated.  The</span>
<span class="cm"> * |namelen| and |valuelen| do not include terminal NULL.  If</span>
<span class="cm"> * `nghttp2_option_set_no_http_messaging()` is used with nonzero</span>
<span class="cm"> * value, NULL character may be included in |name| or |value| before</span>
<span class="cm"> * terminating NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that unless `nghttp2_option_set_no_http_messaging()` is</span>
<span class="cm"> * used, nghttp2 library does perform validation against the |name|</span>
<span class="cm"> * and the |value| using `nghttp2_check_header_name()` and</span>
<span class="cm"> * `nghttp2_check_header_value()`.  In addition to this, nghttp2</span>
<span class="cm"> * performs validation based on HTTP Messaging rule, which is briefly</span>
<span class="cm"> * explained in :ref:`http-messaging` section.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory pointed</span>
<span class="cm"> * by |frame|, |name| and |value| parameters are retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce these parameters, because it may refer to the memory region</span>
<span class="cm"> * included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close</span>
<span class="cm"> * the stream (promised stream if frame is PUSH_PROMISE) by issuing</span>
<span class="cm"> * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,</span>
<span class="cm"> * :type:`nghttp2_on_header_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a</span>
<span class="cm"> * different error code is desirable, use</span>
<span class="cm"> * `nghttp2_submit_rst_stream()` with a desired error code and then</span>
<span class="cm"> * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use</span>
<span class="cm"> * ``frame-&gt;push_promise.promised_stream_id`` as stream_id parameter</span>
<span class="cm"> * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * It may return :enum:`NGHTTP2_ERR_PAUSE` or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  For other critical</span>
<span class="cm"> * failures, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * the other nonzero value is returned, it is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_header_callback()`.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Application should properly limit the total buffer size to store</span>
<span class="cm"> *   incoming header fields.  Without it, peer may send large number</span>
<span class="cm"> *   of header fields or large header fields to cause out of memory in</span>
<span class="cm"> *   local endpoint.  Due to how HPACK works, peer can do this</span>
<span class="cm"> *   effectively without using much memory on their own.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_header_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span>
                                          <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a header name/value pair is received</span>
<span class="cm"> * for the |frame|.  The |name| is header name.  The |value| is header</span>
<span class="cm"> * value.  The |flags| is bitwise OR of one or more of</span>
<span class="cm"> * :type:`nghttp2_nv_flag`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback behaves like :type:`nghttp2_on_header_callback`,</span>
<span class="cm"> * except that |name| and |value| are stored in reference counted</span>
<span class="cm"> * buffer.  If application wishes to keep these references without</span>
<span class="cm"> * copying them, use `nghttp2_rcbuf_incref()` to increment their</span>
<span class="cm"> * reference count.  It is the application&#39;s responsibility to call</span>
<span class="cm"> * `nghttp2_rcbuf_decref()` if they called `nghttp2_rcbuf_incref()` so</span>
<span class="cm"> * as not to leak memory.  If the |session| is created by</span>
<span class="cm"> * `nghttp2_session_server_new3()` or `nghttp2_session_client_new3()`,</span>
<span class="cm"> * the function to free memory is the one belongs to the mem</span>
<span class="cm"> * parameter.  As long as this free function alives, |name| and</span>
<span class="cm"> * |value| can live after |session| was destroyed.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_header_callback2</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                           <span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                           <span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                           <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a invalid header name/value pair is</span>
<span class="cm"> * received for the |frame|.</span>
<span class="cm"> *</span>
<span class="cm"> * The parameter and behaviour are similar to</span>
<span class="cm"> * :type:`nghttp2_on_header_callback`.  The difference is that this</span>
<span class="cm"> * callback is only invoked when a invalid header name/value pair is</span>
<span class="cm"> * received which is silently ignored if this callback is not set.</span>
<span class="cm"> * Only invalid regular header field are passed to this callback.  In</span>
<span class="cm"> * other words, invalid pseudo header field is not passed to this</span>
<span class="cm"> * callback.  Also header fields which includes upper cased latter are</span>
<span class="cm"> * also treated as error without passing them to this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is only considered if HTTP messaging validation is</span>
<span class="cm"> * turned on (which is on by default, see</span>
<span class="cm"> * `nghttp2_option_set_no_http_messaging()`).</span>
<span class="cm"> *</span>
<span class="cm"> * With this callback, application inspects the incoming invalid</span>
<span class="cm"> * field, and it also can reset stream from this callback by returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the</span>
<span class="cm"> * error code is :enum:`NGHTTP2_INTERNAL_ERROR`.  To change the error</span>
<span class="cm"> * code, call `nghttp2_submit_rst_stream()` with the error code of</span>
<span class="cm"> * choice in addition to returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_invalid_header_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a invalid header name/value pair is</span>
<span class="cm"> * received for the |frame|.</span>
<span class="cm"> *</span>
<span class="cm"> * The parameter and behaviour are similar to</span>
<span class="cm"> * :type:`nghttp2_on_header_callback2`.  The difference is that this</span>
<span class="cm"> * callback is only invoked when a invalid header name/value pair is</span>
<span class="cm"> * received which is silently ignored if this callback is not set.</span>
<span class="cm"> * Only invalid regular header field are passed to this callback.  In</span>
<span class="cm"> * other words, invalid pseudo header field is not passed to this</span>
<span class="cm"> * callback.  Also header fields which includes upper cased latter are</span>
<span class="cm"> * also treated as error without passing them to this callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is only considered if HTTP messaging validation is</span>
<span class="cm"> * turned on (which is on by default, see</span>
<span class="cm"> * `nghttp2_option_set_no_http_messaging()`).</span>
<span class="cm"> *</span>
<span class="cm"> * With this callback, application inspects the incoming invalid</span>
<span class="cm"> * field, and it also can reset stream from this callback by returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  By default, the</span>
<span class="cm"> * error code is :enum:`NGHTTP2_INTERNAL_ERROR`.  To change the error</span>
<span class="cm"> * code, call `nghttp2_submit_rst_stream()` with the error code of</span>
<span class="cm"> * choice in addition to returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_invalid_header_callback2</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
    <span class="n">nghttp2_rcbuf</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library asks application how</span>
<span class="cm"> * many padding bytes are required for the transmission of the</span>
<span class="cm"> * |frame|.  The application must choose the total length of payload</span>
<span class="cm"> * including padded bytes in range [frame-&gt;hd.length, max_payloadlen],</span>
<span class="cm"> * inclusive.  Choosing number not in this range will be treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Returning</span>
<span class="cm"> * ``frame-&gt;hd.length`` means no padding is added.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make</span>
<span class="cm"> * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_select_padding_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_select_padding_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                   <span class="kt">size_t</span> <span class="n">max_payloadlen</span><span class="p">,</span>
                                                   <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when library wants to get max length of</span>
<span class="cm"> * data to send data to the remote peer.  The implementation of this</span>
<span class="cm"> * function should return a value in the following range.  [1,</span>
<span class="cm"> * min(|session_remote_window_size|, |stream_remote_window_size|,</span>
<span class="cm"> * |remote_max_frame_size|)].  If a value greater than this range is</span>
<span class="cm"> * returned than the max allow value will be used.  Returning a value</span>
<span class="cm"> * smaller than this range is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The |frame_type| is provided</span>
<span class="cm"> * for future extensibility and identifies the type of frame (see</span>
<span class="cm"> * :type:`nghttp2_frame_type`) for which to get the length for.</span>
<span class="cm"> * Currently supported frame types are: :enum:`NGHTTP2_DATA`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback can be used to control the length in bytes for which</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback` is allowed to send to the</span>
<span class="cm"> * remote endpoint.  This callback is optional.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_data_source_read_length_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_data_source_read_length_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">frame_type</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
    <span class="kt">int32_t</span> <span class="n">session_remote_window_size</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_remote_window_size</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">remote_max_frame_size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a frame header is received.  The</span>
<span class="cm"> * |hd| points to received frame header.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike :type:`nghttp2_on_frame_recv_callback`, this callback will</span>
<span class="cm"> * also be called when frame header of CONTINUATION frame is received.</span>
<span class="cm"> *</span>
<span class="cm"> * If both :type:`nghttp2_on_begin_frame_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_begin_headers_callback` are set and HEADERS or</span>
<span class="cm"> * PUSH_PROMISE is received, :type:`nghttp2_on_begin_frame_callback`</span>
<span class="cm"> * will be called first.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero value is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To set this callback to :type:`nghttp2_session_callbacks`, use</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_begin_frame_callback()`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_begin_frame_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">nghttp2_frame_hd</span> <span class="o">*</span><span class="n">hd</span><span class="p">,</span>
                                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when chunk of extension frame payload is</span>
<span class="cm"> * received.  The |hd| points to frame header.  The received</span>
<span class="cm"> * chunk is |data| of length |len|.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * To abort processing this extension frame, return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CANCEL`.</span>
<span class="cm"> *</span>
<span class="cm"> * If fatal error occurred, application should return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the</span>
<span class="cm"> * other values are returned, currently they are treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_extension_chunk_recv_callback</span><span class="p">)(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame_hd</span> <span class="o">*</span><span class="n">hd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when library asks the application to</span>
<span class="cm"> * unpack extension payload from its wire format.  The extension</span>
<span class="cm"> * payload has been passed to the application using</span>
<span class="cm"> * :type:`nghttp2_on_extension_chunk_recv_callback`.  The frame header</span>
<span class="cm"> * is already unpacked by the library and provided as |hd|.</span>
<span class="cm"> *</span>
<span class="cm"> * To receive extension frames, the application must tell desired</span>
<span class="cm"> * extension frame type to the library using</span>
<span class="cm"> * `nghttp2_option_set_user_recv_extension_type()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function may store the pointer to the</span>
<span class="cm"> * created object as a result of unpacking in |*payload|, and returns</span>
<span class="cm"> * 0.  The pointer stored in |*payload| is opaque to the library, and</span>
<span class="cm"> * the library does not own its pointer.  |*payload| is initialized as</span>
<span class="cm"> * ``NULL``.  The |*payload| is available as ``frame-&gt;ext.payload`` in</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback`.  Therefore if application</span>
<span class="cm"> * can free that memory inside :type:`nghttp2_on_frame_recv_callback`</span>
<span class="cm"> * callback.  Of course, application has a liberty not ot use</span>
<span class="cm"> * |*payload|, and do its own mechanism to process extension frames.</span>
<span class="cm"> *</span>
<span class="cm"> * To abort processing this extension frame, return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CANCEL`.</span>
<span class="cm"> *</span>
<span class="cm"> * If fatal error occurred, application should return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the</span>
<span class="cm"> * other values are returned, currently they are treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_unpack_extension_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                 <span class="kt">void</span> <span class="o">**</span><span class="n">payload</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">nghttp2_frame_hd</span> <span class="o">*</span><span class="n">hd</span><span class="p">,</span>
                                                 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when library asks the application to pack</span>
<span class="cm"> * extension payload in its wire format.  The frame header will be</span>
<span class="cm"> * packed by library.  Application must pack payload only.</span>
<span class="cm"> * ``frame-&gt;ext.payload`` is the object passed to</span>
<span class="cm"> * `nghttp2_submit_extension()` as payload parameter.  Application</span>
<span class="cm"> * must pack extension payload to the |buf| of its capacity |len|</span>
<span class="cm"> * bytes.  The |len| is at least 16KiB.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function should return the number of</span>
<span class="cm"> * bytes written into |buf| when it succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * To abort processing this extension frame, return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CANCEL`, and</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` will be invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * If fatal error occurred, application should return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,</span>
<span class="cm"> * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the</span>
<span class="cm"> * other values are returned, currently they are treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the return value is</span>
<span class="cm"> * strictly larger than |len|, it is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_pack_extension_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                   <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                                   <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when library provides the error message</span>
<span class="cm"> * intended for human consumption.  This callback is solely for</span>
<span class="cm"> * debugging purpose.  The |msg| is typically NULL-terminated string</span>
<span class="cm"> * of length |len|.  |len| does not include the sentinel NULL</span>
<span class="cm"> * character.</span>
<span class="cm"> *</span>
<span class="cm"> * The format of error message may change between nghttp2 library</span>
<span class="cm"> * versions.  The application should not depend on the particular</span>
<span class="cm"> * format.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, application should return 0 from this callback.  If fatal</span>
<span class="cm"> * error occurred while doing something in this callback, application</span>
<span class="cm"> * should return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  In this case,</span>
<span class="cm"> * library will return immediately with return value</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Currently, if nonzero value</span>
<span class="cm"> * is returned from this callback, they are treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`, but application should not</span>
<span class="cm"> * rely on this details.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_error_callback</span><span class="p">)(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_session_callbacks</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Callback functions for :type:`nghttp2_session`.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_session_callbacks</span> <span class="n">nghttp2_session_callbacks</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*callbacks_ptr| with NULL values.</span>
<span class="cm"> *</span>
<span class="cm"> * The initialized object can be used when initializing multiple</span>
<span class="cm"> * :type:`nghttp2_session` objects.</span>
<span class="cm"> *</span>
<span class="cm"> * When the application finished using this object, it can use</span>
<span class="cm"> * `nghttp2_session_callbacks_del()` to free its memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_callbacks_new</span><span class="p">(</span><span class="n">nghttp2_session_callbacks</span> <span class="o">**</span><span class="n">callbacks_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |callbacks|.  If |callbacks| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_session_callbacks_del</span><span class="p">(</span><span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a session wants to send data to</span>
<span class="cm"> * the remote peer.  This callback is not necessary if the application</span>
<span class="cm"> * uses solely `nghttp2_session_mem_send()` to serialize data to</span>
<span class="cm"> * transmit.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span> <span class="n">nghttp2_send_callback</span> <span class="n">send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the a session wants to receive</span>
<span class="cm"> * data from the remote peer.  This callback is not necessary if the</span>
<span class="cm"> * application uses solely `nghttp2_session_mem_recv()` to process</span>
<span class="cm"> * received data.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span> <span class="n">nghttp2_recv_callback</span> <span class="n">recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked by `nghttp2_session_recv()` and</span>
<span class="cm"> * `nghttp2_session_mem_recv()` when a frame is received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_recv_callback</span> <span class="n">on_frame_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked by `nghttp2_session_recv()` and</span>
<span class="cm"> * `nghttp2_session_mem_recv()` when an invalid non-DATA frame is</span>
<span class="cm"> * received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_session_callbacks_set_on_invalid_frame_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_invalid_frame_recv_callback</span> <span class="n">on_invalid_frame_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a chunk of data in DATA frame</span>
<span class="cm"> * is received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_data_chunk_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_data_chunk_recv_callback</span> <span class="n">on_data_chunk_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked before a non-DATA frame is sent.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_before_frame_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_before_frame_send_callback</span> <span class="n">before_frame_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked after a frame is sent.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_send_callback</span> <span class="n">on_frame_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a non-DATA frame is not sent</span>
<span class="cm"> * because of an error.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_frame_not_send_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_frame_not_send_callback</span> <span class="n">on_frame_not_send_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the stream is closed.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_stream_close_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_stream_close_callback</span> <span class="n">on_stream_close_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the reception of header block</span>
<span class="cm"> * in HEADERS or PUSH_PROMISE is started.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_begin_headers_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_begin_headers_callback</span> <span class="n">on_begin_headers_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a header name/value pair is</span>
<span class="cm"> * received.  If both</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_header_callback()` and</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_header_callback2()` are used to</span>
<span class="cm"> * set callbacks, the latter has the precedence.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_header_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_header_callback</span> <span class="n">on_header_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a header name/value pair is</span>
<span class="cm"> * received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_header_callback2</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_header_callback2</span> <span class="n">on_header_callback2</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a invalid header name/value</span>
<span class="cm"> * pair is received.  If both</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_invalid_header_callback()` and</span>
<span class="cm"> * `nghttp2_session_callbacks_set_on_invalid_header_callback2()` are</span>
<span class="cm"> * used to set callbacks, the latter takes the precedence.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_invalid_header_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_invalid_header_callback</span> <span class="n">on_invalid_header_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a invalid header name/value</span>
<span class="cm"> * pair is received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_invalid_header_callback2</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_invalid_header_callback2</span> <span class="n">on_invalid_header_callback2</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the library asks application</span>
<span class="cm"> * how many padding bytes are required for the transmission of the</span>
<span class="cm"> * given frame.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_select_padding_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_select_padding_callback</span> <span class="n">select_padding_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function determine the length allowed in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_session_callbacks_set_data_source_read_length_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_data_source_read_length_callback</span> <span class="n">data_source_read_length_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when a frame header is received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_on_begin_frame_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_begin_frame_callback</span> <span class="n">on_begin_frame_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_COPY` is used in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback` to avoid data copy.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_send_data_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_send_data_callback</span> <span class="n">send_data_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the library asks the</span>
<span class="cm"> * application to pack extension frame payload in wire format.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_pack_extension_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_pack_extension_callback</span> <span class="n">pack_extension_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when the library asks the</span>
<span class="cm"> * application to unpack extension frame payload from wire format.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_unpack_extension_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_unpack_extension_callback</span> <span class="n">unpack_extension_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when chunk of extension frame</span>
<span class="cm"> * payload is received.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_session_callbacks_set_on_extension_chunk_recv_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span>
    <span class="n">nghttp2_on_extension_chunk_recv_callback</span> <span class="n">on_extension_chunk_recv_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets callback function invoked when library tells error message to</span>
<span class="cm"> * the application.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_callbacks_set_error_callback</span><span class="p">(</span>
    <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">cbs</span><span class="p">,</span> <span class="n">nghttp2_error_callback</span> <span class="n">error_callback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace malloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_malloc</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace free().  The |mem_user_data| is</span>
<span class="cm"> * the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace calloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_calloc</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator to replace realloc().  The |mem_user_data|</span>
<span class="cm"> * is the mem_user_data member of :type:`nghttp2_mem` structure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nghttp2_realloc</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Custom memory allocator functions and user defined pointer.  The</span>
<span class="cm"> * |mem_user_data| member is passed to each allocator function.  This</span>
<span class="cm"> * can be used, for example, to achieve per-session memory pool.</span>
<span class="cm"> *</span>
<span class="cm"> * In the following example code, ``my_malloc``, ``my_free``,</span>
<span class="cm"> * ``my_calloc`` and ``my_realloc`` are the replacement of the</span>
<span class="cm"> * standard allocators ``malloc``, ``free``, ``calloc`` and</span>
<span class="cm"> * ``realloc`` respectively::</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_malloc_cb(size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_malloc(size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void my_free_cb(void *ptr, void *mem_user_data) { my_free(ptr); }</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_calloc_cb(size_t nmemb, size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_calloc(nmemb, size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void *my_realloc_cb(void *ptr, size_t size, void *mem_user_data) {</span>
<span class="cm"> *       return my_realloc(ptr, size);</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> *     void session_new() {</span>
<span class="cm"> *       nghttp2_session *session;</span>
<span class="cm"> *       nghttp2_session_callbacks *callbacks;</span>
<span class="cm"> *       nghttp2_mem mem = {NULL, my_malloc_cb, my_free_cb, my_calloc_cb,</span>
<span class="cm"> *                          my_realloc_cb};</span>
<span class="cm"> *</span>
<span class="cm"> *       ...</span>
<span class="cm"> *</span>
<span class="cm"> *       nghttp2_session_client_new3(&amp;session, callbacks, NULL, NULL, &amp;mem);</span>
<span class="cm"> *</span>
<span class="cm"> *       ...</span>
<span class="cm"> *     }</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * An arbitrary user supplied data.  This is passed to each</span>
<span class="cm">   * allocator function.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">mem_user_data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace malloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_malloc</span> <span class="n">malloc</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace free().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_free</span> <span class="n">free</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace calloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_calloc</span> <span class="n">calloc</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Custom allocator function to replace realloc().</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_realloc</span> <span class="n">realloc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_mem</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Configuration options for :type:`nghttp2_session`.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_option</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*option_ptr| with default values.</span>
<span class="cm"> *</span>
<span class="cm"> * When the application finished using this object, it can use</span>
<span class="cm"> * `nghttp2_option_del()` to free its memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_option_new</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">**</span><span class="n">option_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |option|.  If |option| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_option_del</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from sending WINDOW_UPDATE for a</span>
<span class="cm"> * connection automatically.  If this option is set to nonzero, the</span>
<span class="cm"> * library won&#39;t send WINDOW_UPDATE for DATA until application calls</span>
<span class="cm"> * `nghttp2_session_consume()` to indicate the consumed amount of</span>
<span class="cm"> * data.  Don&#39;t use `nghttp2_submit_window_update()` for this purpose.</span>
<span class="cm"> * By default, this option is set to zero.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_no_auto_window_update</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of</span>
<span class="cm"> * remote endpoint as if it is received in SETTINGS frame.  Without</span>
<span class="cm"> * specifying this option, before the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS in SETTINGS frame from remote</span>
<span class="cm"> * endpoint, SETTINGS_MAX_CONCURRENT_STREAMS is unlimited.  This may</span>
<span class="cm"> * cause problem if local endpoint submits lots of requests initially</span>
<span class="cm"> * and sending them at once to the remote peer may lead to the</span>
<span class="cm"> * rejection of some requests.  Specifying this option to the sensible</span>
<span class="cm"> * value, say 100, may avoid this kind of issue. This value will be</span>
<span class="cm"> * overwritten if the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS from the remote endpoint.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_peer_max_concurrent_streams</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                               <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * By default, nghttp2 library, if configured as server, requires</span>
<span class="cm"> * first 24 bytes of client magic byte string (MAGIC).  In most cases,</span>
<span class="cm"> * this will simplify the implementation of server.  But sometimes</span>
<span class="cm"> * server may want to detect the application protocol based on first</span>
<span class="cm"> * few bytes on clear text communication.</span>
<span class="cm"> *</span>
<span class="cm"> * If this option is used with nonzero |val|, nghttp2 library does not</span>
<span class="cm"> * handle MAGIC.  It still checks following SETTINGS frame.  This</span>
<span class="cm"> * means that applications should deal with MAGIC by themselves.</span>
<span class="cm"> *</span>
<span class="cm"> * If this option is not used or used with zero value, if MAGIC does</span>
<span class="cm"> * not match :macro:`NGHTTP2_CLIENT_MAGIC`, `nghttp2_session_recv()`</span>
<span class="cm"> * and `nghttp2_session_mem_recv()` will return error</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`, which is fatal error.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_no_recv_client_magic</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * By default, nghttp2 library enforces subset of HTTP Messaging rules</span>
<span class="cm"> * described in `HTTP/2 specification, section 8</span>
<span class="cm"> * &lt;https://tools.ietf.org/html/rfc7540#section-8&gt;`_.  See</span>
<span class="cm"> * :ref:`http-messaging` section for details.  For those applications</span>
<span class="cm"> * who use nghttp2 library as non-HTTP use, give nonzero to |val| to</span>
<span class="cm"> * disable this enforcement.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_option_set_no_http_messaging</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                         <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 7540 does not enforce any limit on the number of incoming</span>
<span class="cm"> * reserved streams (in RFC 7540 terms, streams in reserved (remote)</span>
<span class="cm"> * state).  This only affects client side, since only server can push</span>
<span class="cm"> * streams.  Malicious server can push arbitrary number of streams,</span>
<span class="cm"> * and make client&#39;s memory exhausted.  This option can set the</span>
<span class="cm"> * maximum number of such incoming streams to avoid possible memory</span>
<span class="cm"> * exhaustion.  If this option is set, and pushed streams are</span>
<span class="cm"> * automatically closed on reception, without calling user provided</span>
<span class="cm"> * callback, if they exceed the given limit.  The default value is</span>
<span class="cm"> * 200.  If session is configured as server side, this option has no</span>
<span class="cm"> * effect.  Server can control the number of streams to push.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_max_reserved_remote_streams</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                               <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets extension frame type the application is willing to handle with</span>
<span class="cm"> * user defined callbacks (see</span>
<span class="cm"> * :type:`nghttp2_on_extension_chunk_recv_callback` and</span>
<span class="cm"> * :type:`nghttp2_unpack_extension_callback`).  The |type| is</span>
<span class="cm"> * extension frame type, and must be strictly greater than 0x9.</span>
<span class="cm"> * Otherwise, this function does nothing.  The application can call</span>
<span class="cm"> * this function multiple times to set more than one frame type to</span>
<span class="cm"> * receive.  The application does not have to call this function if it</span>
<span class="cm"> * just sends extension frames.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_user_recv_extension_type</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                            <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets extension frame type the application is willing to receive</span>
<span class="cm"> * using builtin handler.  The |type| is the extension frame type to</span>
<span class="cm"> * receive, and must be strictly greater than 0x9.  Otherwise, this</span>
<span class="cm"> * function does nothing.  The application can call this function</span>
<span class="cm"> * multiple times to set more than one frame type to receive.  The</span>
<span class="cm"> * application does not have to call this function if it just sends</span>
<span class="cm"> * extension frames.</span>
<span class="cm"> *</span>
<span class="cm"> * If same frame type is passed to both</span>
<span class="cm"> * `nghttp2_option_set_builtin_recv_extension_type()` and</span>
<span class="cm"> * `nghttp2_option_set_user_recv_extension_type()`, the latter takes</span>
<span class="cm"> * precedence.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_builtin_recv_extension_type</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                               <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from sending PING frame with ACK</span>
<span class="cm"> * flag set automatically when PING frame without ACK flag set is</span>
<span class="cm"> * received.  If this option is set to nonzero, the library won&#39;t send</span>
<span class="cm"> * PING frame with ACK flag set in the response for incoming PING</span>
<span class="cm"> * frame.  The application can send PING frame with ACK flag set using</span>
<span class="cm"> * `nghttp2_submit_ping()` with :enum:`NGHTTP2_FLAG_ACK` as flags</span>
<span class="cm"> * parameter.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_option_set_no_auto_ping_ack</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                        <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option sets the maximum length of header block (a set of</span>
<span class="cm"> * header fields per one HEADERS frame) to send.  The length of a</span>
<span class="cm"> * given set of header fields is calculated using</span>
<span class="cm"> * `nghttp2_hd_deflate_bound()`.  The default value is 64KiB.  If</span>
<span class="cm"> * application attempts to send header fields larger than this limit,</span>
<span class="cm"> * the transmission of the frame fails with error code</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FRAME_SIZE_ERROR`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_max_send_header_block_length</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                <span class="kt">size_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option sets the maximum dynamic table size for deflating</span>
<span class="cm"> * header fields.  The default value is 4KiB.  In HTTP/2, receiver of</span>
<span class="cm"> * deflated header block can specify maximum dynamic table size.  The</span>
<span class="cm"> * actual maximum size is the minimum of the size receiver specified</span>
<span class="cm"> * and this option value.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_option_set_max_deflate_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                  <span class="kt">size_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from retaining closed streams to</span>
<span class="cm"> * maintain the priority tree.  If this option is set to nonzero,</span>
<span class="cm"> * applications can discard closed stream completely to save memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_option_set_no_closed_streams</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                         <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for client use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|.  Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :type:`nghttp2_send_callback` must be specified.  If the</span>
<span class="cm"> * application code uses `nghttp2_session_recv()`, the</span>
<span class="cm"> * :type:`nghttp2_recv_callback` must be specified.  The other members</span>
<span class="cm"> * of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*session_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_client_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for server use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|. Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :type:`nghttp2_send_callback` must be specified.  If the</span>
<span class="cm"> * application code uses `nghttp2_session_recv()`, the</span>
<span class="cm"> * :type:`nghttp2_recv_callback` must be specified.  The other members</span>
<span class="cm"> * of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*session_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_server_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_client_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_client_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_client_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_server_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_server_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_client_new2()`, but with additional custom</span>
<span class="cm"> * memory allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_client_new2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_client_new3</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_server_new2()`, but with additional custom</span>
<span class="cm"> * memory allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_server_new2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_server_new3</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |session|.  If |session| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_session_del</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sends pending frames to the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function retrieves the highest prioritized frame from the</span>
<span class="cm"> * outbound queue and sends it to the remote peer.  It does this as</span>
<span class="cm"> * many as possible until the user callback</span>
<span class="cm"> * :type:`nghttp2_send_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK` or the outbound queue becomes empty.</span>
<span class="cm"> * This function calls several callback functions which are passed</span>
<span class="cm"> * when initializing the |session|.  Here is the simple time chart</span>
<span class="cm"> * which tells when each callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Get the next frame to send from outbound queue.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. Prepare transmission of the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. If the control frame cannot be sent because some preconditions</span>
<span class="cm"> *    are not met (e.g., request HEADERS cannot be sent after GOAWAY),</span>
<span class="cm"> *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort</span>
<span class="cm"> *    the following steps.</span>
<span class="cm"> *</span>
<span class="cm"> * 4. If the frame is HEADERS, PUSH_PROMISE or DATA,</span>
<span class="cm"> *    :type:`nghttp2_select_padding_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 5. If the frame is request HEADERS, the stream is opened here.</span>
<span class="cm"> *</span>
<span class="cm"> * 6. :type:`nghttp2_before_frame_send_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 7. If :enum:`NGHTTP2_ERR_CANCEL` is returned from</span>
<span class="cm"> *    :type:`nghttp2_before_frame_send_callback`, the current frame</span>
<span class="cm"> *    transmission is canceled, and</span>
<span class="cm"> *    :type:`nghttp2_on_frame_not_send_callback` is invoked.  Abort</span>
<span class="cm"> *    the following steps.</span>
<span class="cm"> *</span>
<span class="cm"> * 8. :type:`nghttp2_send_callback` is invoked one or more times to</span>
<span class="cm"> *    send the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * 9. :type:`nghttp2_on_frame_send_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 10. If the transmission of the frame triggers closure of the</span>
<span class="cm"> *     stream, the stream is closed and</span>
<span class="cm"> *     :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the serialized data to send.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_send()` except that it</span>
<span class="cm"> * does not use :type:`nghttp2_send_callback` to transmit data.</span>
<span class="cm"> * Instead, it assigns the pointer to the serialized data to the</span>
<span class="cm"> * |*data_ptr| and returns its length.  The other callbacks are called</span>
<span class="cm"> * in the same way as they are in `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If no data is available to send, this function returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not return all serialized data in one invocation.</span>
<span class="cm"> * To get all data, call this function repeatedly until it returns 0</span>
<span class="cm"> * or one of negative error codes.</span>
<span class="cm"> *</span>
<span class="cm"> * The assigned |*data_ptr| is valid until the next call of</span>
<span class="cm"> * `nghttp2_session_mem_send()` or `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must send all data before sending the next chunk of</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the length of the data pointed by the</span>
<span class="cm"> * |*data_ptr| if it succeeds, or one of the following negative error</span>
<span class="cm"> * codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> *</span>
<span class="cm"> * .. note::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function may produce very small byte string.  If that is the</span>
<span class="cm"> *   case, and application disables Nagle algorithm (``TCP_NODELAY``),</span>
<span class="cm"> *   then writing this small chunk leads to very small packet, and it</span>
<span class="cm"> *   is very inefficient.  An application should be responsible to</span>
<span class="cm"> *   buffer up small chunks of data as necessary to avoid this</span>
<span class="cm"> *   situation.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">data_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Receives frames from the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives as many frames as possible until the user</span>
<span class="cm"> * callback :type:`nghttp2_recv_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  This function calls several</span>
<span class="cm"> * callback functions which are passed when initializing the</span>
<span class="cm"> * |session|.  Here is the simple time chart which tells when each</span>
<span class="cm"> * callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. :type:`nghttp2_recv_callback` is invoked one or more times to</span>
<span class="cm"> *    receive frame header.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. When frame header is received,</span>
<span class="cm"> *    :type:`nghttp2_on_begin_frame_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. If the frame is DATA frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :type:`nghttp2_recv_callback` is invoked to receive DATA</span>
<span class="cm"> *       payload. For each chunk of data,</span>
<span class="cm"> *       :type:`nghttp2_on_data_chunk_recv_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> *    2. If one DATA frame is completely received,</span>
<span class="cm"> *       :type:`nghttp2_on_frame_recv_callback` is invoked.  If the</span>
<span class="cm"> *       reception of the frame triggers the closure of the stream,</span>
<span class="cm"> *       :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 4. If the frame is the control frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :type:`nghttp2_recv_callback` is invoked one or more times to</span>
<span class="cm"> *       receive whole frame.</span>
<span class="cm"> *</span>
<span class="cm"> *    2. If the received frame is valid, then following actions are</span>
<span class="cm"> *       taken.  If the frame is either HEADERS or PUSH_PROMISE,</span>
<span class="cm"> *       :type:`nghttp2_on_begin_headers_callback` is invoked.  Then</span>
<span class="cm"> *       :type:`nghttp2_on_header_callback` is invoked for each header</span>
<span class="cm"> *       name/value pair.  For invalid header field,</span>
<span class="cm"> *       :type:`nghttp2_on_invalid_header_callback` is called.  After</span>
<span class="cm"> *       all name/value pairs are emitted successfully,</span>
<span class="cm"> *       :type:`nghttp2_on_frame_recv_callback` is invoked.  For other</span>
<span class="cm"> *       frames, :type:`nghttp2_on_frame_recv_callback` is invoked.</span>
<span class="cm"> *       If the reception of the frame triggers the closure of the</span>
<span class="cm"> *       stream, :type:`nghttp2_on_stream_close_callback` is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> *    3. If the received frame is unpacked but is interpreted as</span>
<span class="cm"> *       invalid, :type:`nghttp2_on_invalid_frame_recv_callback` is</span>
<span class="cm"> *       invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_EOF`</span>
<span class="cm"> *     The remote peer did shutdown on the connection.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`</span>
<span class="cm"> *     Invalid client magic was detected.  This error only returns</span>
<span class="cm"> *     when |session| was configured as server and</span>
<span class="cm"> *     `nghttp2_option_set_no_recv_client_magic()` is not used with</span>
<span class="cm"> *     nonzero value.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FLOODED`</span>
<span class="cm"> *     Flooding was detected in this HTTP/2 session, and it must be</span>
<span class="cm"> *     closed.  This is most likely caused by misbehaviour of peer.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Processes data |in| as an input from the remote endpoint.  The</span>
<span class="cm"> * |inlen| indicates the number of bytes in the |in|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_recv()` except that it</span>
<span class="cm"> * does not use :type:`nghttp2_recv_callback` to receive data; the</span>
<span class="cm"> * |in| is the only data for the invocation of this function.  If all</span>
<span class="cm"> * bytes are processed, this function returns.  The other callbacks</span>
<span class="cm"> * are called in the same way as they are in `nghttp2_session_recv()`.</span>
<span class="cm"> *</span>
<span class="cm"> * In the current implementation, this function always tries to</span>
<span class="cm"> * processes all input data unless either an error occurs or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` is returned from</span>
<span class="cm"> * :type:`nghttp2_on_header_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_data_chunk_recv_callback`.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` is used, the return value includes the</span>
<span class="cm"> * number of bytes which was used to produce the data or frame for the</span>
<span class="cm"> * callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of processed bytes, or one of the</span>
<span class="cm"> * following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BAD_CLIENT_MAGIC`</span>
<span class="cm"> *     Invalid client magic was detected.  This error only returns</span>
<span class="cm"> *     when |session| was configured as server and</span>
<span class="cm"> *     `nghttp2_option_set_no_recv_client_magic()` is not used with</span>
<span class="cm"> *     nonzero value.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FLOODED`</span>
<span class="cm"> *     Flooding was detected in this HTTP/2 session, and it must be</span>
<span class="cm"> *     closed.  This is most likely caused by misbehaviour of peer.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                                <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Puts back previously deferred DATA frame in the stream |stream_id|</span>
<span class="cm"> * to the outbound queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist; or no deferred data exist.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_resume_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                               <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to receive data from the</span>
<span class="cm"> * remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_want_read</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to send data to the remote</span>
<span class="cm"> * peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_want_write</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns stream_user_data for the stream |stream_id|.  The</span>
<span class="cm"> * stream_user_data is provided by `nghttp2_submit_request()`,</span>
<span class="cm"> * `nghttp2_submit_headers()` or</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`.  Unless it is set using</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`, if the stream is</span>
<span class="cm"> * initiated by the remote endpoint, stream_user_data is always</span>
<span class="cm"> * ``NULL``.  If the stream does not exist, this function returns</span>
<span class="cm"> * ``NULL``.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">nghttp2_session_get_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                     <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the |stream_user_data| to the stream denoted by the</span>
<span class="cm"> * |stream_id|.  If a stream user data is already set to the stream,</span>
<span class="cm"> * it is replaced with the |stream_user_data|.  It is valid to specify</span>
<span class="cm"> * ``NULL`` in the |stream_user_data|, which nullifies the associated</span>
<span class="cm"> * data pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * It is valid to set the |stream_user_data| to the stream reserved by</span>
<span class="cm"> * PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_set_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                     <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of frames in the outbound queue.  This does not</span>
<span class="cm"> * include the deferred DATA frames.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">size_t</span>
<span class="nf">nghttp2_session_get_outbound_queue_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for the stream |stream_id|.  The local</span>
<span class="cm"> * (receive) window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective data length.  In particular, if the</span>
<span class="cm"> * local window size is reduced by submitting negative</span>
<span class="cm"> * window_size_increment with `nghttp2_submit_window_update()`, this</span>
<span class="cm"> * function returns the number of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_effective_recv_data_length</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for the stream |stream_id|.</span>
<span class="cm"> * The local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take into account the amount of received</span>
<span class="cm"> * data from the remote endpoint.  Use</span>
<span class="cm"> * `nghttp2_session_get_stream_local_window_size()` to know the amount</span>
<span class="cm"> * of data the remote endpoint can send without receiving stream level</span>
<span class="cm"> * WINDOW_UPDATE frame.  Note that each stream is still subject to the</span>
<span class="cm"> * connection level flow control.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_effective_local_window_size</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the amount of flow-controlled payload (e.g., DATA) that the</span>
<span class="cm"> * remote endpoint can send without receiving stream level</span>
<span class="cm"> * WINDOW_UPDATE frame.  It is also subject to the connection level</span>
<span class="cm"> * flow control.  So the actual amount of data to send is</span>
<span class="cm"> * min(`nghttp2_session_get_stream_local_window_size()`,</span>
<span class="cm"> * `nghttp2_session_get_local_window_size()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_local_window_size</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for a connection.  The local (receive)</span>
<span class="cm"> * window size can be adjusted by `nghttp2_submit_window_update()`.</span>
<span class="cm"> * This function takes into account that and returns effective data</span>
<span class="cm"> * length.  In particular, if the local window size is reduced by</span>
<span class="cm"> * submitting negative window_size_increment with</span>
<span class="cm"> * `nghttp2_submit_window_update()`, this function returns the number</span>
<span class="cm"> * of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_effective_recv_data_length</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for a connection.  The</span>
<span class="cm"> * local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take into account the amount of received</span>
<span class="cm"> * data from the remote endpoint.  Use</span>
<span class="cm"> * `nghttp2_session_get_local_window_size()` to know the amount of</span>
<span class="cm"> * data the remote endpoint can send without receiving</span>
<span class="cm"> * connection-level WINDOW_UPDATE frame.  Note that each stream is</span>
<span class="cm"> * still subject to the stream level flow control.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_effective_local_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the amount of flow-controlled payload (e.g., DATA) that the</span>
<span class="cm"> * remote endpoint can send without receiving connection level</span>
<span class="cm"> * WINDOW_UPDATE frame.  Note that each stream is still subject to the</span>
<span class="cm"> * stream level flow control (see</span>
<span class="cm"> * `nghttp2_session_get_stream_local_window_size()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_local_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remote window size for a given stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the amount of flow-controlled payload (e.g., DATA) that the</span>
<span class="cm"> * local endpoint can send without stream level WINDOW_UPDATE.  There</span>
<span class="cm"> * is also connection level flow control, so the effective size of</span>
<span class="cm"> * payload that the local endpoint can actually send is</span>
<span class="cm"> * min(`nghttp2_session_get_stream_remote_window_size()`,</span>
<span class="cm"> * `nghttp2_session_get_remote_window_size()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_remote_window_size</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remote window size for a connection.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always succeeds.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_remote_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if local peer half closed the given stream |stream_id|.</span>
<span class="cm"> * Returns 0 if it did not.  Returns -1 if no such stream exists.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_get_stream_local_close</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if remote peer half closed the given stream |stream_id|.</span>
<span class="cm"> * Returns 0 if it did not.  Returns -1 if no such stream exists.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_get_stream_remote_close</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                        <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current dynamic table size of HPACK inflater, including</span>
<span class="cm"> * the overhead 32 bytes per entry described in RFC 7541.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">size_t</span>
<span class="nf">nghttp2_session_get_hd_inflate_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current dynamic table size of HPACK deflater including</span>
<span class="cm"> * the overhead 32 bytes per entry described in RFC 7541.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">size_t</span>
<span class="nf">nghttp2_session_get_hd_deflate_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the session so that the connection should be terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * The last stream ID is the minimum value between the stream ID of a</span>
<span class="cm"> * stream for which :type:`nghttp2_on_frame_recv_callback` was called</span>
<span class="cm"> * most recently and the last stream ID we have sent to the peer</span>
<span class="cm"> * previously.</span>
<span class="cm"> *</span>
<span class="cm"> * The |error_code| is the error code of this GOAWAY frame.  The</span>
<span class="cm"> * pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * After the transmission, both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called when the connection should be</span>
<span class="cm"> * terminated after sending GOAWAY.  If the remaining streams should</span>
<span class="cm"> * be processed after GOAWAY, use `nghttp2_submit_goaway()` instead.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_terminate_session</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                     <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the session so that the connection should be terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_terminate_session()`,</span>
<span class="cm"> * but the last stream ID can be specified by the application for fine</span>
<span class="cm"> * grained control of stream.  The HTTP/2 specification does not allow</span>
<span class="cm"> * last_stream_id to be increased.  So the actual value sent as</span>
<span class="cm"> * last_stream_id is the minimum value between the given</span>
<span class="cm"> * |last_stream_id| and the last_stream_id we have previously sent to</span>
<span class="cm"> * the peer.</span>
<span class="cm"> *</span>
<span class="cm"> * The |last_stream_id| is peer&#39;s stream ID or 0.  So if |session| is</span>
<span class="cm"> * initialized as client, |last_stream_id| must be even or 0.  If</span>
<span class="cm"> * |session| is initialized as server, |last_stream_id| must be odd or</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |last_stream_id| is invalid.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_terminate_session2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">,</span>
                                                      <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals to the client that the server started graceful shutdown</span>
<span class="cm"> * procedure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only usable for server.  If this function is</span>
<span class="cm"> * called with client side session, this function returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`.</span>
<span class="cm"> *</span>
<span class="cm"> * To gracefully shutdown HTTP/2 session, server should call this</span>
<span class="cm"> * function to send GOAWAY with last_stream_id (1u &lt;&lt; 31) - 1.  And</span>
<span class="cm"> * after some delay (e.g., 1 RTT), send another GOAWAY with the stream</span>
<span class="cm"> * ID that the server has some processing using</span>
<span class="cm"> * `nghttp2_submit_goaway()`.  See also</span>
<span class="cm"> * `nghttp2_session_get_last_proc_stream_id()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike `nghttp2_submit_goaway()`, this function just sends GOAWAY</span>
<span class="cm"> * and does nothing more.  This is a mere indication to the client</span>
<span class="cm"> * that session shutdown is imminent.  The application should call</span>
<span class="cm"> * `nghttp2_submit_goaway()` with appropriate last_stream_id after</span>
<span class="cm"> * this call.</span>
<span class="cm"> *</span>
<span class="cm"> * If one or more GOAWAY frame have been already sent by either</span>
<span class="cm"> * `nghttp2_submit_goaway()` or `nghttp2_session_terminate_session()`,</span>
<span class="cm"> * this function has no effect.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     The |session| is initialized as client.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_shutdown_notice</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the value of SETTINGS |id| notified by a remote endpoint.</span>
<span class="cm"> * The |id| must be one of values defined in</span>
<span class="cm"> * :enum:`nghttp2_settings_id`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">uint32_t</span> <span class="nf">nghttp2_session_get_remote_settings</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">nghttp2_settings_id</span> <span class="n">id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the value of SETTINGS |id| of local endpoint acknowledged</span>
<span class="cm"> * by the remote endpoint.  The |id| must be one of the values defined</span>
<span class="cm"> * in :enum:`nghttp2_settings_id`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">uint32_t</span> <span class="nf">nghttp2_session_get_local_settings</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="n">nghttp2_settings_id</span> <span class="n">id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the |session| that next stream ID is |next_stream_id|.  The</span>
<span class="cm"> * |next_stream_id| must be equal or greater than the value returned</span>
<span class="cm"> * by `nghttp2_session_get_next_stream_id()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |next_stream_id| is strictly less than the value</span>
<span class="cm"> *     `nghttp2_session_get_next_stream_id()` returns; or</span>
<span class="cm"> *     |next_stream_id| is invalid (e.g., even integer for client, or</span>
<span class="cm"> *     odd integer for server).</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_set_next_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">int32_t</span> <span class="n">next_stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next outgoing stream ID.  Notice that return type is</span>
<span class="cm"> * uint32_t.  If we run out of stream ID for this session, this</span>
<span class="cm"> * function returns 1 &lt;&lt; 31.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">uint32_t</span>
<span class="nf">nghttp2_session_get_next_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the |session| that |size| bytes for a stream denoted by</span>
<span class="cm"> * |stream_id| were consumed by application and are ready to</span>
<span class="cm"> * WINDOW_UPDATE.  The consumed bytes are counted towards both</span>
<span class="cm"> * connection and stream level WINDOW_UPDATE (see</span>
<span class="cm"> * `nghttp2_session_consume_connection()` and</span>
<span class="cm"> * `nghttp2_session_consume_stream()` to update consumption</span>
<span class="cm"> * independently).  This function is intended to be used without</span>
<span class="cm"> * automatic window update (see</span>
<span class="cm"> * `nghttp2_option_set_no_auto_window_update()`).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     Automatic WINDOW_UPDATE is not disabled.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_consume</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_consume()`, but this only tells library that</span>
<span class="cm"> * |size| bytes were consumed only for connection level.  Note that</span>
<span class="cm"> * HTTP/2 maintains connection and stream level flow control windows</span>
<span class="cm"> * independently.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     Automatic WINDOW_UPDATE is not disabled.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_consume_connection</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_consume()`, but this only tells library that</span>
<span class="cm"> * |size| bytes were consumed only for stream denoted by |stream_id|.</span>
<span class="cm"> * Note that HTTP/2 maintains connection and stream level flow control</span>
<span class="cm"> * windows independently.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     Automatic WINDOW_UPDATE is not disabled.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_consume_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                  <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Changes priority of existing stream denoted by |stream_id|.  The</span>
<span class="cm"> * new priority specification is |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * The priority is changed silently and instantly, and no PRIORITY</span>
<span class="cm"> * frame will be sent to notify the peer of this change.  This</span>
<span class="cm"> * function may be useful for server to change the priority of pushed</span>
<span class="cm"> * stream.</span>
<span class="cm"> *</span>
<span class="cm"> * If |session| is initialized as server, and ``pri_spec-&gt;stream_id``</span>
<span class="cm"> * points to the idle stream, the idle stream is created if it does</span>
<span class="cm"> * not exist.  The created idle stream will depend on root stream</span>
<span class="cm"> * (stream 0) with weight 16.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if stream denoted by ``pri_spec-&gt;stream_id`` is not</span>
<span class="cm"> * found, we use default priority instead of given |pri_spec|.  That</span>
<span class="cm"> * is make stream depend on root stream with weight 16.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     Attempted to depend on itself; or no stream exist for the given</span>
<span class="cm"> *     |stream_id|; or |stream_id| is 0</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_change_stream_priority</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Creates idle stream with the given |stream_id|, and priority</span>
<span class="cm"> * |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * The stream creation is done without sending PRIORITY frame, which</span>
<span class="cm"> * means that peer does not know about the existence of this idle</span>
<span class="cm"> * stream in the local endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 7540 does not disallow the use of creation of idle stream with</span>
<span class="cm"> * odd or even stream ID regardless of client or server.  So this</span>
<span class="cm"> * function can create odd or even stream ID regardless of client or</span>
<span class="cm"> * server.  But probably it is a bit safer to use the stream ID the</span>
<span class="cm"> * local endpoint can initiate (in other words, use odd stream ID for</span>
<span class="cm"> * client, and even stream ID for server), to avoid potential</span>
<span class="cm"> * collision from peer&#39;s instruction.  Also we can use</span>
<span class="cm"> * `nghttp2_session_set_next_stream_id()` to avoid to open created</span>
<span class="cm"> * idle streams accidentally if we follow this recommendation.</span>
<span class="cm"> *</span>
<span class="cm"> * If |session| is initialized as server, and ``pri_spec-&gt;stream_id``</span>
<span class="cm"> * points to the idle stream, the idle stream is created if it does</span>
<span class="cm"> * not exist.  The created idle stream will depend on root stream</span>
<span class="cm"> * (stream 0) with weight 16.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, if stream denoted by ``pri_spec-&gt;stream_id`` is not</span>
<span class="cm"> * found, we use default priority instead of given |pri_spec|.  That</span>
<span class="cm"> * is make stream depend on root stream with weight 16.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     Attempted to depend on itself; or stream denoted by |stream_id|</span>
<span class="cm"> *     already exists; or |stream_id| cannot be used to create idle</span>
<span class="cm"> *     stream (in other words, local endpoint has already opened</span>
<span class="cm"> *     stream ID greater than or equal to the given stream ID; or</span>
<span class="cm"> *     |stream_id| is 0</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_create_idle_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Performs post-process of HTTP Upgrade request.  This function can</span>
<span class="cm"> * be called from both client and server, but the behavior is very</span>
<span class="cm"> * different in each other.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function is deprecated in favor of</span>
<span class="cm"> *   `nghttp2_session_upgrade2()`, because this function lacks the</span>
<span class="cm"> *   parameter to tell the library the request method used in the</span>
<span class="cm"> *   original HTTP request.  This information is required for client</span>
<span class="cm"> *   to validate actual response body length against content-length</span>
<span class="cm"> *   header field (see `nghttp2_option_set_no_http_messaging()`).  If</span>
<span class="cm"> *   HEAD is used in request, the length of response body must be 0</span>
<span class="cm"> *   regardless of value included in content-length header field.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from client side, the |settings_payload| must be the</span>
<span class="cm"> * value sent in ``HTTP2-Settings`` header field and must be decoded</span>
<span class="cm"> * by base64url decoder.  The |settings_payloadlen| is the length of</span>
<span class="cm"> * |settings_payload|.  The |settings_payload| is unpacked and its</span>
<span class="cm"> * setting values will be submitted using `nghttp2_submit_settings()`.</span>
<span class="cm"> * This means that the client application code does not need to submit</span>
<span class="cm"> * SETTINGS by itself.  The stream with stream ID=1 is opened and the</span>
<span class="cm"> * |stream_user_data| is used for its stream_user_data.  The opened</span>
<span class="cm"> * stream becomes half-closed (local) state.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from server side, the |settings_payload| must be the</span>
<span class="cm"> * value received in ``HTTP2-Settings`` header field and must be</span>
<span class="cm"> * decoded by base64url decoder.  The |settings_payloadlen| is the</span>
<span class="cm"> * length of |settings_payload|.  It is treated as if the SETTINGS</span>
<span class="cm"> * frame with that payload is received.  Thus, callback functions for</span>
<span class="cm"> * the reception of SETTINGS frame will be invoked.  The stream with</span>
<span class="cm"> * stream ID=1 is opened.  The |stream_user_data| is ignored.  The</span>
<span class="cm"> * opened stream becomes half-closed (remote).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |settings_payload| is badly formed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The stream ID 1 is already used or closed; or is not available.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_upgrade</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">settings_payload</span><span class="p">,</span>
                                           <span class="kt">size_t</span> <span class="n">settings_payloadlen</span><span class="p">,</span>
                                           <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Performs post-process of HTTP Upgrade request.  This function can</span>
<span class="cm"> * be called from both client and server, but the behavior is very</span>
<span class="cm"> * different in each other.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from client side, the |settings_payload| must be the</span>
<span class="cm"> * value sent in ``HTTP2-Settings`` header field and must be decoded</span>
<span class="cm"> * by base64url decoder.  The |settings_payloadlen| is the length of</span>
<span class="cm"> * |settings_payload|.  The |settings_payload| is unpacked and its</span>
<span class="cm"> * setting values will be submitted using `nghttp2_submit_settings()`.</span>
<span class="cm"> * This means that the client application code does not need to submit</span>
<span class="cm"> * SETTINGS by itself.  The stream with stream ID=1 is opened and the</span>
<span class="cm"> * |stream_user_data| is used for its stream_user_data.  The opened</span>
<span class="cm"> * stream becomes half-closed (local) state.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from server side, the |settings_payload| must be the</span>
<span class="cm"> * value received in ``HTTP2-Settings`` header field and must be</span>
<span class="cm"> * decoded by base64url decoder.  The |settings_payloadlen| is the</span>
<span class="cm"> * length of |settings_payload|.  It is treated as if the SETTINGS</span>
<span class="cm"> * frame with that payload is received.  Thus, callback functions for</span>
<span class="cm"> * the reception of SETTINGS frame will be invoked.  The stream with</span>
<span class="cm"> * stream ID=1 is opened.  The |stream_user_data| is ignored.  The</span>
<span class="cm"> * opened stream becomes half-closed (remote).</span>
<span class="cm"> *</span>
<span class="cm"> * If the request method is HEAD, pass nonzero value to</span>
<span class="cm"> * |head_request|.  Otherwise, pass 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |settings_payload| is badly formed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The stream ID 1 is already used or closed; or is not available.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_session_upgrade2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">settings_payload</span><span class="p">,</span>
                                            <span class="kt">size_t</span> <span class="n">settings_payloadlen</span><span class="p">,</span>
                                            <span class="kt">int</span> <span class="n">head_request</span><span class="p">,</span>
                                            <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Serializes the SETTINGS values |iv| in the |buf|.  The size of the</span>
<span class="cm"> * |buf| is specified by |buflen|.  The number of entries in the |iv|</span>
<span class="cm"> * array is given by |niv|.  The required space in |buf| for the |niv|</span>
<span class="cm"> * entries is ``6*niv`` bytes and if the given buffer is too small, an</span>
<span class="cm"> * error is returned.  This function is used mainly for creating a</span>
<span class="cm"> * SETTINGS payload to be sent with the ``HTTP2-Settings`` header</span>
<span class="cm"> * field in an HTTP Upgrade request.  The data written in |buf| is NOT</span>
<span class="cm"> * base64url encoded and the application is responsible for encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes written in |buf|, or one</span>
<span class="cm"> * of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains duplicate settings ID or invalid value.</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_pack_settings_payload</span><span class="p">(</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns string describing the |lib_error_code|.  The</span>
<span class="cm"> * |lib_error_code| must be one of the :enum:`nghttp2_error`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nghttp2_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns string representation of HTTP/2 error code |error_code|</span>
<span class="cm"> * (e.g., ``PROTOCOL_ERROR`` is returned if ``error_code ==</span>
<span class="cm"> * NGHTTP2_PROTOCOL_ERROR``).  If string representation is unknown for</span>
<span class="cm"> * given |error_code|, this function returns string ``unknown``.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nghttp2_http2_strerror</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the |stream_id| of the stream to depend</span>
<span class="cm"> * on with |weight| and its exclusive flag.  If |exclusive| is</span>
<span class="cm"> * nonzero, exclusive flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The |weight| must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_priority_spec_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                                               <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                               <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exclusive</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the default values.  The default values</span>
<span class="cm"> * are: stream_id = 0, weight = :macro:`NGHTTP2_DEFAULT_WEIGHT` and</span>
<span class="cm"> * exclusive = 0.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span>
<span class="nf">nghttp2_priority_spec_default_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the |pri_spec| is filled with default values.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_priority_spec_check_default</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame and optionally one or more DATA frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``pri_spec-&gt;weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec-&gt;weight`` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.  For header fields with</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name</span>
<span class="cm"> * and value are not copied respectively.  With</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to</span>
<span class="cm"> * pass header field name in lowercase.  The application should</span>
<span class="cm"> * maintain the references to them until</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` is called.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * request HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  In this case, a method that allows</span>
<span class="cm"> * request message bodies</span>
<span class="cm"> * (https://tools.ietf.org/html/rfc7231#section-4) must be specified</span>
<span class="cm"> * with ``:method`` key in |nva| (e.g. ``POST``).  This function does</span>
<span class="cm"> * not take ownership of the |data_prd|.  The function copies the</span>
<span class="cm"> * members of the |data_prd|.  If |data_prd| is ``NULL``, HEADERS have</span>
<span class="cm"> * END_STREAM set.  The |stream_user_data| is data associated to the</span>
<span class="cm"> * stream opened by this request and can be an arbitrary pointer,</span>
<span class="cm"> * which can be retrieved later by</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns assigned stream ID if it succeeds, or one of</span>
<span class="cm"> * the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     Trying to depend on itself (new stream ID equals</span>
<span class="cm"> *     ``pri_spec-&gt;stream_id``).</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The |session| is server session.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned stream ID if it succeeds.  But</span>
<span class="cm"> *   that stream is not opened yet.  The application must not submit</span>
<span class="cm"> *   frame to that stream ID before</span>
<span class="cm"> *   :type:`nghttp2_before_frame_send_callback` is called for this</span>
<span class="cm"> *   frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_submit_request</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits response HEADERS frame and optionally one or more DATA</span>
<span class="cm"> * frames against the stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.  For header fields with</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name</span>
<span class="cm"> * and value are not copied respectively.  With</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to</span>
<span class="cm"> * pass header field name in lowercase.  The application should</span>
<span class="cm"> * maintain the references to them until</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` is called.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * response HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  This function does not take ownership</span>
<span class="cm"> * of the |data_prd|.  The function copies the members of the</span>
<span class="cm"> * |data_prd|.  If |data_prd| is ``NULL``, HEADERS will have</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This method can be used as normal HTTP response and push response.</span>
<span class="cm"> * When pushing a resource using this function, the |session| must be</span>
<span class="cm"> * configured using `nghttp2_session_server_new()` or its variants and</span>
<span class="cm"> * the target stream denoted by the |stream_id| must be reserved using</span>
<span class="cm"> * `nghttp2_submit_push_promise()`.</span>
<span class="cm"> *</span>
<span class="cm"> * To send non-final response headers (e.g., HTTP status 101), don&#39;t</span>
<span class="cm"> * use this function because this function half-closes the outbound</span>
<span class="cm"> * stream.  Instead, use `nghttp2_submit_headers()` for this purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *     DATA or HEADERS has been already submitted and not fully</span>
<span class="cm"> *     processed yet.  Normally, this does not happen, but when</span>
<span class="cm"> *     application wrongly calls `nghttp2_submit_response()` twice,</span>
<span class="cm"> *     this may happen.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The |session| is client session.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Calling this function twice for the same stream ID may lead to</span>
<span class="cm"> *   program crash.  It is generally considered to a programming error</span>
<span class="cm"> *   to commit response twice.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_submit_response</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits trailer fields HEADERS against the stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible not to include</span>
<span class="cm"> * pseudo-header fields (header field whose name starts with &quot;:&quot;) in</span>
<span class="cm"> * |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.  For header fields with</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name</span>
<span class="cm"> * and value are not copied respectively.  With</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to</span>
<span class="cm"> * pass header field name in lowercase.  The application should</span>
<span class="cm"> * maintain the references to them until</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` is called.</span>
<span class="cm"> *</span>
<span class="cm"> * For server, trailer fields must follow response HEADERS or response</span>
<span class="cm"> * DATA without END_STREAM flat set.  The library does not enforce</span>
<span class="cm"> * this requirement, and applications should do this for themselves.</span>
<span class="cm"> * If `nghttp2_submit_trailer()` is called before any response HEADERS</span>
<span class="cm"> * submission (usually by `nghttp2_submit_response()`), the content of</span>
<span class="cm"> * |nva| will be sent as response headers, which will result in error.</span>
<span class="cm"> *</span>
<span class="cm"> * This function has the same effect with `nghttp2_submit_headers()`,</span>
<span class="cm"> * with flags = :enum:`NGHTTP2_FLAG_END_STREAM` and both pri_spec and</span>
<span class="cm"> * stream_user_data to NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * To submit trailer fields after `nghttp2_submit_response()` is</span>
<span class="cm"> * called, the application has to specify</span>
<span class="cm"> * :type:`nghttp2_data_provider` to `nghttp2_submit_response()`.</span>
<span class="cm"> * Inside of :type:`nghttp2_data_source_read_callback`, when setting</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_EOF`, also set</span>
<span class="cm"> * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM`.  After that, the</span>
<span class="cm"> * application can send trailer fields using</span>
<span class="cm"> * `nghttp2_submit_trailer()`.  `nghttp2_submit_trailer()` can be used</span>
<span class="cm"> * inside :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds and |stream_id| is -1.</span>
<span class="cm"> * Otherwise, this function returns 0 if it succeeds, or one of the</span>
<span class="cm"> * following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_trailer</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                          <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame. The |flags| is bitwise OR of the</span>
<span class="cm"> * following values:</span>
<span class="cm"> *</span>
<span class="cm"> * * :enum:`NGHTTP2_FLAG_END_STREAM`</span>
<span class="cm"> *</span>
<span class="cm"> * If |flags| includes :enum:`NGHTTP2_FLAG_END_STREAM`, this frame has</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * The library handles the CONTINUATION frame internally and it</span>
<span class="cm"> * correctly sets END_HEADERS to the last sequence of the PUSH_PROMISE</span>
<span class="cm"> * or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |stream_id| is -1, this frame is assumed as request (i.e.,</span>
<span class="cm"> * request HEADERS frame which opens new stream).  In this case, the</span>
<span class="cm"> * assigned stream ID will be returned.  Otherwise, specify stream ID</span>
<span class="cm"> * in |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``pri_spec-&gt;weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec-&gt;weight`` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.  For header fields with</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name</span>
<span class="cm"> * and value are not copied respectively.  With</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to</span>
<span class="cm"> * pass header field name in lowercase.  The application should</span>
<span class="cm"> * maintain the references to them until</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` is called.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_user_data| is a pointer to an arbitrary data which is</span>
<span class="cm"> * associated to the stream this frame will open.  Therefore it is</span>
<span class="cm"> * only used if this frame opens streams, in other words, it changes</span>
<span class="cm"> * stream state from idle or reserved to open.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is low-level in a sense that the application code can</span>
<span class="cm"> * specify flags directly.  For usual HTTP request,</span>
<span class="cm"> * `nghttp2_submit_request()` is useful.  Likewise, for HTTP response,</span>
<span class="cm"> * prefer `nghttp2_submit_response()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns newly assigned stream ID if it succeeds and</span>
<span class="cm"> * |stream_id| is -1.  Otherwise, this function returns 0 if it</span>
<span class="cm"> * succeeds, or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0; or trying to depend on itself (stream ID</span>
<span class="cm"> *     equals ``pri_spec-&gt;stream_id``).</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *     DATA or HEADERS has been already submitted and not fully</span>
<span class="cm"> *     processed yet.  This happens if stream denoted by |stream_id|</span>
<span class="cm"> *     is in reserved state.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The |stream_id| is -1, and |session| is server session.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned stream ID if it succeeds and</span>
<span class="cm"> *   |stream_id| is -1.  But that stream is not opened yet.  The</span>
<span class="cm"> *   application must not submit frame to that stream ID before</span>
<span class="cm"> *   :type:`nghttp2_before_frame_send_callback` is called for this</span>
<span class="cm"> *   frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_submit_headers</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits one or more DATA frames to the stream |stream_id|.  The</span>
<span class="cm"> * data to be sent are provided by |data_prd|.  If |flags| contains</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_STREAM`, the last DATA frame has END_STREAM</span>
<span class="cm"> * flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |data_prd|.  The</span>
<span class="cm"> * function copies the members of the |data_prd|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *     DATA or HEADERS has been already submitted and not fully</span>
<span class="cm"> *     processed yet.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_CLOSED`</span>
<span class="cm"> *     The stream was already closed; or the |stream_id| is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * .. note::</span>
<span class="cm"> *</span>
<span class="cm"> *   Currently, only one DATA or HEADERS is allowed for a stream at a</span>
<span class="cm"> *   time.  Submitting these frames more than once before first DATA</span>
<span class="cm"> *   or HEADERS is finished results in :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *   error code.  The earliest callback which tells that previous</span>
<span class="cm"> *   frame is done is :type:`nghttp2_on_frame_send_callback`.  In side</span>
<span class="cm"> *   that callback, new data can be submitted using</span>
<span class="cm"> *   `nghttp2_submit_data()`.  Of course, all data except for last one</span>
<span class="cm"> *   must not have :enum:`NGHTTP2_FLAG_END_STREAM` flag set in</span>
<span class="cm"> *   |flags|.  This sounds a bit complicated, and we recommend to use</span>
<span class="cm"> *   `nghttp2_submit_request()` and `nghttp2_submit_response()` to</span>
<span class="cm"> *   avoid this cascading issue.  The experience shows that for HTTP</span>
<span class="cm"> *   use, these two functions are enough to implement both client and</span>
<span class="cm"> *   server.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PRIORITY frame to change the priority of stream |stream_id|</span>
<span class="cm"> * to the priority specification |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * is not allowed for this function. To specify the priority, use</span>
<span class="cm"> * `nghttp2_priority_spec_init()`.  This function will copy its data</span>
<span class="cm"> * members.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``pri_spec-&gt;weight`` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If ``pri_spec-&gt;weight`` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0; or the |pri_spec| is NULL; or trying to</span>
<span class="cm"> *     depend on itself.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_submit_priority</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits RST_STREAM frame to cancel/reject the stream |stream_id|</span>
<span class="cm"> * with the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_rst_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                             <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                             <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Stores local settings and submits SETTINGS frame.  The |iv| is the</span>
<span class="cm"> * pointer to the array of :type:`nghttp2_settings_entry`.  The |niv|</span>
<span class="cm"> * indicates the number of :type:`nghttp2_settings_entry`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |iv|.  This function</span>
<span class="cm"> * copies all the elements in the |iv|.</span>
<span class="cm"> *</span>
<span class="cm"> * While updating individual stream&#39;s local window size, if the window</span>
<span class="cm"> * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,</span>
<span class="cm"> * RST_STREAM is issued against such a stream.</span>
<span class="cm"> *</span>
<span class="cm"> * SETTINGS with :enum:`NGHTTP2_FLAG_ACK` is automatically submitted</span>
<span class="cm"> * by the library and application could not send it at its will.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains invalid value (e.g., initial window size</span>
<span class="cm"> *     strictly greater than (1 &lt;&lt; 31) - 1.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_settings</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
                                           <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored.  The library handles the</span>
<span class="cm"> * CONTINUATION frame internally and it correctly sets END_HEADERS to</span>
<span class="cm"> * the last sequence of the PUSH_PROMISE or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_id| must be client initiated stream ID.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The application is responsible to include</span>
<span class="cm"> * required pseudo-header fields (header field whose name starts with</span>
<span class="cm"> * &quot;:&quot;) in |nva| and must place pseudo-headers before regular header</span>
<span class="cm"> * fields.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.  The order of elements in</span>
<span class="cm"> * |nva| is preserved.  For header fields with</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME` and</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_VALUE` are set, header field name</span>
<span class="cm"> * and value are not copied respectively.  With</span>
<span class="cm"> * :enum:`NGHTTP2_NV_FLAG_NO_COPY_NAME`, application is responsible to</span>
<span class="cm"> * pass header field name in lowercase.  The application should</span>
<span class="cm"> * maintain the references to them until</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` or</span>
<span class="cm"> * :type:`nghttp2_on_frame_not_send_callback` is called.</span>
<span class="cm"> *</span>
<span class="cm"> * The |promised_stream_user_data| is a pointer to an arbitrary data</span>
<span class="cm"> * which is associated to the promised stream this frame will open and</span>
<span class="cm"> * make it in reserved state.  It is available using</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.  The application can</span>
<span class="cm"> * access it in :type:`nghttp2_before_frame_send_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` of this frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The client side is not allowed to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * To submit response headers and data, use</span>
<span class="cm"> * `nghttp2_submit_response()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns assigned promised stream ID if it succeeds,</span>
<span class="cm"> * or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     This function was invoked when |session| is initialized as</span>
<span class="cm"> *     client.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE`</span>
<span class="cm"> *     No stream ID is available because maximum stream ID was</span>
<span class="cm"> *     reached.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is 0; The |stream_id| does not designate stream</span>
<span class="cm"> *     that peer initiated.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_STREAM_CLOSED`</span>
<span class="cm"> *     The stream was already closed; or the |stream_id| is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   This function returns assigned promised stream ID if it succeeds.</span>
<span class="cm"> *   As of 1.16.0, stream object for pushed resource is created when</span>
<span class="cm"> *   this function succeeds.  In that case, the application can submit</span>
<span class="cm"> *   push response for the promised frame.</span>
<span class="cm"> *</span>
<span class="cm"> *   In 1.15.0 or prior versions, pushed stream is not opened yet when</span>
<span class="cm"> *   this function succeeds.  The application must not submit frame to</span>
<span class="cm"> *   that stream ID before :type:`nghttp2_before_frame_send_callback`</span>
<span class="cm"> *   is called for this frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_submit_push_promise</span><span class="p">(</span>
    <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">promised_stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PING frame.  You don&#39;t have to send PING back when you</span>
<span class="cm"> * received PING frame.  The library automatically submits PING frame</span>
<span class="cm"> * in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is bitwise OR of 0 or more of the following value.</span>
<span class="cm"> *</span>
<span class="cm"> * * :enum:`NGHTTP2_FLAG_ACK`</span>
<span class="cm"> *</span>
<span class="cm"> * Unless `nghttp2_option_set_no_auto_ping_ack()` is used, the |flags|</span>
<span class="cm"> * should be :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is non ``NULL``, then it should point to the 8</span>
<span class="cm"> * bytes array of memory to specify opaque data to send with PING</span>
<span class="cm"> * frame.  If the |opaque_data| is ``NULL``, zero-cleared 8 bytes will</span>
<span class="cm"> * be sent as opaque data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_ping</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits GOAWAY frame with the last stream ID |last_stream_id| and</span>
<span class="cm"> * the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The pre-defined error code is one of :enum:`nghttp2_error_code`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |last_stream_id| is peer&#39;s stream ID or 0.  So if |session| is</span>
<span class="cm"> * initialized as client, |last_stream_id| must be even or 0.  If</span>
<span class="cm"> * |session| is initialized as server, |last_stream_id| must be odd or</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * The HTTP/2 specification says last_stream_id must not be increased</span>
<span class="cm"> * from the value previously sent.  So the actual value sent as</span>
<span class="cm"> * last_stream_id is the minimum value between the given</span>
<span class="cm"> * |last_stream_id| and the last_stream_id previously sent to the</span>
<span class="cm"> * peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is not ``NULL`` and |opaque_data_len| is not</span>
<span class="cm"> * zero, those data will be sent as additional debug data.  The</span>
<span class="cm"> * library makes a copy of the memory region pointed by |opaque_data|</span>
<span class="cm"> * with the length |opaque_data_len|, so the caller does not need to</span>
<span class="cm"> * keep this memory after the return of this function.  If the</span>
<span class="cm"> * |opaque_data_len| is 0, the |opaque_data| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * After successful transmission of GOAWAY, following things happen.</span>
<span class="cm"> * All incoming streams having strictly more than |last_stream_id| are</span>
<span class="cm"> * closed.  All incoming HEADERS which starts new stream are simply</span>
<span class="cm"> * ignored.  After all active streams are handled, both</span>
<span class="cm"> * `nghttp2_session_want_read()` and `nghttp2_session_want_write()`</span>
<span class="cm"> * return 0 and the application can close session.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |opaque_data_len| is too large; the |last_stream_id| is</span>
<span class="cm"> *     invalid.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_goaway</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">,</span>
                                         <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the last stream ID of a stream for which</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` was invoked most recently.</span>
<span class="cm"> * The returned value can be used as last_stream_id parameter for</span>
<span class="cm"> * `nghttp2_submit_goaway()` and</span>
<span class="cm"> * `nghttp2_session_terminate_session2()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always succeeds.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_session_get_last_proc_stream_id</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if new request can be sent from local endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * This function return 0 if request is not allowed for this session.</span>
<span class="cm"> * There are several reasons why request is not allowed.  Some of the</span>
<span class="cm"> * reasons are: session is server; stream ID has been spent; GOAWAY</span>
<span class="cm"> * has been sent or received.</span>
<span class="cm"> *</span>
<span class="cm"> * The application can call `nghttp2_submit_request()` without</span>
<span class="cm"> * consulting this function.  In that case, `nghttp2_submit_request()`</span>
<span class="cm"> * may return error.  Or, request is failed to sent, and</span>
<span class="cm"> * :type:`nghttp2_on_stream_close_callback` is called.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_check_request_allowed</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if |session| is initialized as server side session.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_check_server_session</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits WINDOW_UPDATE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_id| is the stream ID to send this WINDOW_UPDATE.  To</span>
<span class="cm"> * send connection level WINDOW_UPDATE, specify 0 to |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is positive, the WINDOW_UPDATE with</span>
<span class="cm"> * that value as window_size_increment is queued.  If the</span>
<span class="cm"> * |window_size_increment| is larger than the received bytes from the</span>
<span class="cm"> * remote endpoint, the local window size is increased by that</span>
<span class="cm"> * difference.  If the sole purpose is to increase the local window</span>
<span class="cm"> * size, consider to use `nghttp2_session_set_local_window_size()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is negative, the local window size</span>
<span class="cm"> * is decreased by -|window_size_increment|.  If automatic</span>
<span class="cm"> * WINDOW_UPDATE is enabled</span>
<span class="cm"> * (`nghttp2_option_set_no_auto_window_update()`), and the library</span>
<span class="cm"> * decided that the WINDOW_UPDATE should be submitted, then</span>
<span class="cm"> * WINDOW_UPDATE is queued with the current received bytes count.  If</span>
<span class="cm"> * the sole purpose is to decrease the local window size, consider to</span>
<span class="cm"> * use `nghttp2_session_set_local_window_size()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is 0, the function does nothing and</span>
<span class="cm"> * returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FLOW_CONTROL`</span>
<span class="cm"> *     The local window size overflow or gets negative.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_window_update</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                                <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                                <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Set local window size (local endpoints&#39;s window size) to the given</span>
<span class="cm"> * |window_size| for the given stream denoted by |stream_id|.  To</span>
<span class="cm"> * change connection level window size, specify 0 to |stream_id|.  To</span>
<span class="cm"> * increase window size, this function may submit WINDOW_UPDATE frame</span>
<span class="cm"> * to transmission queue.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This sounds similar to `nghttp2_submit_window_update()`, but there</span>
<span class="cm"> * are 2 differences.  The first difference is that this function</span>
<span class="cm"> * takes the absolute value of window size to set, rather than the</span>
<span class="cm"> * delta.  To change the window size, this may be easier to use since</span>
<span class="cm"> * the application just declares the intended window size, rather than</span>
<span class="cm"> * calculating delta.  The second difference is that</span>
<span class="cm"> * `nghttp2_submit_window_update()` affects the received bytes count</span>
<span class="cm"> * which has not acked yet.  By the specification of</span>
<span class="cm"> * `nghttp2_submit_window_update()`, to strictly increase the local</span>
<span class="cm"> * window size, we have to submit delta including all received bytes</span>
<span class="cm"> * count, which might not be desirable in some cases.  On the other</span>
<span class="cm"> * hand, this function does not affect the received bytes count.  It</span>
<span class="cm"> * just sets the local window size to the given value.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |stream_id| is negative.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_session_set_local_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                      <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">window_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits extension frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Application can pass arbitrary frame flags and stream ID in |flags|</span>
<span class="cm"> * and |stream_id| respectively.  The |payload| is opaque pointer, and</span>
<span class="cm"> * it can be accessible though ``frame-&gt;ext.payload`` in</span>
<span class="cm"> * :type:`nghttp2_pack_extension_callback`.  The library will not own</span>
<span class="cm"> * passed |payload| pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * The application must set :type:`nghttp2_pack_extension_callback`</span>
<span class="cm"> * using `nghttp2_session_callbacks_set_pack_extension_callback()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The application should retain the memory pointed by |payload| until</span>
<span class="cm"> * the transmission of extension frame is done (which is indicated by</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback`), or transmission fails</span>
<span class="cm"> * (which is indicated by :type:`nghttp2_on_frame_not_send_callback`).</span>
<span class="cm"> * If application does not touch this memory region after packing it</span>
<span class="cm"> * into a wire format, application can free it inside</span>
<span class="cm"> * :type:`nghttp2_pack_extension_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * The standard HTTP/2 frame cannot be sent with this function, so</span>
<span class="cm"> * |type| must be strictly grater than 0x9.  Otherwise, this function</span>
<span class="cm"> * will fail with error code :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     If :type:`nghttp2_pack_extension_callback` is not set.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     If  |type| specifies  standard  HTTP/2 frame  type.  The  frame</span>
<span class="cm"> *     types  in the  rage [0x0,  0x9], both  inclusive, are  standard</span>
<span class="cm"> *     HTTP/2 frame type, and cannot be sent using this function.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_extension</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                            <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                            <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The payload of ALTSVC frame.  ALTSVC frame is a non-critical</span>
<span class="cm"> * extension to HTTP/2.  If this frame is received, and</span>
<span class="cm"> * `nghttp2_option_set_user_recv_extension_type()` is not set, and</span>
<span class="cm"> * `nghttp2_option_set_builtin_recv_extension_type()` is set for</span>
<span class="cm"> * :enum:`NGHTTP2_ALTSVC`, ``nghttp2_extension.payload`` will point to</span>
<span class="cm"> * this struct.</span>
<span class="cm"> *</span>
<span class="cm"> * It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to origin which this alternative service is</span>
<span class="cm">   * associated with.  This is not necessarily NULL-terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |origin|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to Alt-Svc field value contained in ALTSVC frame.</span>
<span class="cm">   * This is not necessarily NULL-terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">field_value</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |field_value|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">field_value_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_ext_altsvc</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits ALTSVC frame.</span>
<span class="cm"> *</span>
<span class="cm"> * ALTSVC frame is a non-critical extension to HTTP/2, and defined in</span>
<span class="cm"> * is defined in `RFC 7383</span>
<span class="cm"> * &lt;https://tools.ietf.org/html/rfc7838#section-4&gt;`_.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |origin| points to the origin this alternative service is</span>
<span class="cm"> * associated with.  The |origin_len| is the length of the origin.  If</span>
<span class="cm"> * |stream_id| is 0, the origin must be specified.  If |stream_id| is</span>
<span class="cm"> * not zero, the origin must be empty (in other words, |origin_len|</span>
<span class="cm"> * must be 0).</span>
<span class="cm"> *</span>
<span class="cm"> * The ALTSVC frame is only usable from server side.  If this function</span>
<span class="cm"> * is invoked with client side session, this function returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     The function is called from client side session</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The sum of |origin_len| and |field_value_len| is larger than</span>
<span class="cm"> *     16382; or |origin_len| is 0 while |stream_id| is 0; or</span>
<span class="cm"> *     |origin_len| is not 0 while |stream_id| is not 0.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_submit_altsvc</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">field_value</span><span class="p">,</span>
                                         <span class="kt">size_t</span> <span class="n">field_value_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Compares ``lhs-&gt;name`` of length ``lhs-&gt;namelen`` bytes and</span>
<span class="cm"> * ``rhs-&gt;name`` of length ``rhs-&gt;namelen`` bytes.  Returns negative</span>
<span class="cm"> * integer if ``lhs-&gt;name`` is found to be less than ``rhs-&gt;name``; or</span>
<span class="cm"> * returns positive integer if ``lhs-&gt;name`` is found to be greater</span>
<span class="cm"> * than ``rhs-&gt;name``; or returns 0 otherwise.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_nv_compare_name</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * A helper function for dealing with NPN in client side or ALPN in</span>
<span class="cm"> * server side.  The |in| contains peer&#39;s protocol list in preferable</span>
<span class="cm"> * order.  The format of |in| is length-prefixed and not</span>
<span class="cm"> * null-terminated.  For example, ``h2`` and</span>
<span class="cm"> * ``http/1.1`` stored in |in| like this::</span>
<span class="cm"> *</span>
<span class="cm"> *     in[0] = 2</span>
<span class="cm"> *     in[1..2] = &quot;h2&quot;</span>
<span class="cm"> *     in[3] = 8</span>
<span class="cm"> *     in[4..11] = &quot;http/1.1&quot;</span>
<span class="cm"> *     inlen = 12</span>
<span class="cm"> *</span>
<span class="cm"> * The selection algorithm is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. If peer&#39;s list contains HTTP/2 protocol the library supports,</span>
<span class="cm"> *    it is selected and returns 1. The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. If peer&#39;s list contains ``http/1.1``, this function selects</span>
<span class="cm"> *    ``http/1.1`` and returns 0.  The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. This function selects nothing and returns -1 (So called</span>
<span class="cm"> *    non-overlap case).  In this case, |out| and |outlen| are left</span>
<span class="cm"> *    untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * Selecting ``h2`` means that ``h2`` is written into |*out| and its</span>
<span class="cm"> * length (which is 2) is assigned to |*outlen|.</span>
<span class="cm"> *</span>
<span class="cm"> * For ALPN, refer to https://tools.ietf.org/html/rfc7301</span>
<span class="cm"> *</span>
<span class="cm"> * See http://technotes.googlecode.com/git/nextprotoneg.html for more</span>
<span class="cm"> * details about NPN.</span>
<span class="cm"> *</span>
<span class="cm"> * For NPN, to use this method you should do something like::</span>
<span class="cm"> *</span>
<span class="cm"> *     static int select_next_proto_cb(SSL* ssl,</span>
<span class="cm"> *                                     unsigned char **out,</span>
<span class="cm"> *                                     unsigned char *outlen,</span>
<span class="cm"> *                                     const unsigned char *in,</span>
<span class="cm"> *                                     unsigned int inlen,</span>
<span class="cm"> *                                     void *arg)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         int rv;</span>
<span class="cm"> *         rv = nghttp2_select_next_protocol(out, outlen, in, inlen);</span>
<span class="cm"> *         if (rv == -1) {</span>
<span class="cm"> *             return SSL_TLSEXT_ERR_NOACK;</span>
<span class="cm"> *         }</span>
<span class="cm"> *         if (rv == 1) {</span>
<span class="cm"> *             ((MyType*)arg)-&gt;http2_selected = 1;</span>
<span class="cm"> *         }</span>
<span class="cm"> *         return SSL_TLSEXT_ERR_OK;</span>
<span class="cm"> *     }</span>
<span class="cm"> *     ...</span>
<span class="cm"> *     SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb, my_obj);</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_select_next_protocol</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span>
                                                <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a nghttp2_info struct with version information</span>
<span class="cm"> * about the run-time library in use.  The |least_version| argument</span>
<span class="cm"> * can be set to a 24 bit numerical value for the least accepted</span>
<span class="cm"> * version number and if the condition is not met, this function will</span>
<span class="cm"> * return a ``NULL``.  Pass in 0 to skip the version checking.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_info</span> <span class="o">*</span><span class="nf">nghttp2_version</span><span class="p">(</span><span class="kt">int</span> <span class="n">least_version</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the :type:`nghttp2_error` library error code</span>
<span class="cm"> * |lib_error| is fatal.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_is_fatal</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field name |name| of length |len| is</span>
<span class="cm"> * valid according to http://tools.ietf.org/html/rfc7230#section-3.2</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is a header field name in HTTP2, the upper cased alphabet</span>
<span class="cm"> * is treated as error.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_check_header_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field value |value| of length |len|</span>
<span class="cm"> * is valid according to</span>
<span class="cm"> * http://tools.ietf.org/html/rfc7230#section-3.2</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_check_header_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* HPACK API */</span>

<span class="k">struct</span> <span class="n">nghttp2_hd_deflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * HPACK deflater object.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_hd_deflater</span> <span class="n">nghttp2_hd_deflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*deflater_ptr| for deflating name/values pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * The |max_deflate_dynamic_table_size| is the upper bound of header</span>
<span class="cm"> * table size the deflater will use.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*deflater_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_hd_deflate_new</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">**</span><span class="n">deflater_ptr</span><span class="p">,</span>
                       <span class="kt">size_t</span> <span class="n">max_deflate_dynamic_table_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_hd_deflate_new()`, but with additional custom memory</span>
<span class="cm"> * allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_hd_deflate_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_hd_deflate_new2</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">**</span><span class="n">deflater_ptr</span><span class="p">,</span>
                        <span class="kt">size_t</span> <span class="n">max_deflate_dynamic_table_size</span><span class="p">,</span>
                        <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deallocates any resources allocated for |deflater|.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_hd_deflate_del</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Changes header table size of the |deflater| to</span>
<span class="cm"> * |settings_max_dynamic_table_size| bytes.  This may trigger eviction</span>
<span class="cm"> * in the dynamic table.</span>
<span class="cm"> *</span>
<span class="cm"> * The |settings_max_dynamic_table_size| should be the value received</span>
<span class="cm"> * in SETTINGS_HEADER_TABLE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * The deflater never uses more memory than</span>
<span class="cm"> * ``max_deflate_dynamic_table_size`` bytes specified in</span>
<span class="cm"> * `nghttp2_hd_deflate_new()`.  Therefore, if</span>
<span class="cm"> * |settings_max_dynamic_table_size| &gt;</span>
<span class="cm"> * ``max_deflate_dynamic_table_size``, resulting maximum table size</span>
<span class="cm"> * becomes ``max_deflate_dynamic_table_size``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_hd_deflate_change_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                     <span class="kt">size_t</span> <span class="n">settings_max_dynamic_table_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deflates the |nva|, which has the |nvlen| name/value pairs, into</span>
<span class="cm"> * the |buf| of length |buflen|.</span>
<span class="cm"> *</span>
<span class="cm"> * If |buf| is not large enough to store the deflated header block,</span>
<span class="cm"> * this function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The</span>
<span class="cm"> * caller should use `nghttp2_hd_deflate_bound()` to know the upper</span>
<span class="cm"> * bound of buffer size required to deflate given header name/value</span>
<span class="cm"> * pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * Once this function fails, subsequent call of this function always</span>
<span class="cm"> * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.</span>
<span class="cm"> *</span>
<span class="cm"> * After this function returns, it is safe to delete the |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Deflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_deflate_hd</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                             <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span>
                                             <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span>
                                             <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deflates the |nva|, which has the |nvlen| name/value pairs, into</span>
<span class="cm"> * the |veclen| size of buf vector |vec|.  The each size of buffer</span>
<span class="cm"> * must be set in len field of :type:`nghttp2_vec`.  If and only if</span>
<span class="cm"> * one chunk is filled up completely, next chunk will be used.  If</span>
<span class="cm"> * |vec| is not large enough to store the deflated header block, this</span>
<span class="cm"> * function fails with :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`.  The caller</span>
<span class="cm"> * should use `nghttp2_hd_deflate_bound()` to know the upper bound of</span>
<span class="cm"> * buffer size required to deflate given header name/value pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * Once this function fails, subsequent call of this function always</span>
<span class="cm"> * returns :enum:`NGHTTP2_ERR_HEADER_COMP`.</span>
<span class="cm"> *</span>
<span class="cm"> * After this function returns, it is safe to delete the |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Deflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_deflate_hd_vec</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">nghttp2_vec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span>
                                                 <span class="kt">size_t</span> <span class="n">veclen</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span>
                                                 <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an upper bound on the compressed size after deflation of</span>
<span class="cm"> * |nva| of length |nvlen|.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">size_t</span> <span class="nf">nghttp2_hd_deflate_bound</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span>
                                               <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of entries that header table of |deflater|</span>
<span class="cm"> * contains.  This is the sum of the number of static table and</span>
<span class="cm"> * dynamic table, so the return value is at least 61.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_hd_deflate_get_num_table_entries</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the table entry denoted by |idx| from header table of</span>
<span class="cm"> * |deflater|.  The |idx| is 1-based, and idx=1 returns first entry of</span>
<span class="cm"> * static table.  idx=62 returns first entry of dynamic table if it</span>
<span class="cm"> * exists.  Specifying idx=0 is error, and this function returns NULL.</span>
<span class="cm"> * If |idx| is strictly greater than the number of entries the tables</span>
<span class="cm"> * contain, this function returns NULL.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span>
<span class="nf">nghttp2_hd_deflate_get_table_entry</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the used dynamic table size, including the overhead 32</span>
<span class="cm"> * bytes per entry described in RFC 7541.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_hd_deflate_get_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the maximum dynamic table size.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span>
<span class="nf">nghttp2_hd_deflate_get_max_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_deflater</span> <span class="o">*</span><span class="n">deflater</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_hd_inflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * HPACK inflater object.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_hd_inflater</span> <span class="n">nghttp2_hd_inflater</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*inflater_ptr| for inflating name/values pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function fails, |*inflater_ptr| is left untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_new</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">**</span><span class="n">inflater_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_hd_inflate_new()`, but with additional custom memory</span>
<span class="cm"> * allocator specified in the |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |mem| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_hd_inflate_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |mem|.  The application is</span>
<span class="cm"> * responsible for freeing |mem|.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |mem| pointer after this</span>
<span class="cm"> * function returns, so the application can safely free it.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span> <span class="nf">nghttp2_hd_inflate_new2</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">**</span><span class="n">inflater_ptr</span><span class="p">,</span>
                                           <span class="n">nghttp2_mem</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Deallocates any resources allocated for |inflater|.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_hd_inflate_del</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Changes header table size in the |inflater|.  This may trigger</span>
<span class="cm"> * eviction in the dynamic table.</span>
<span class="cm"> *</span>
<span class="cm"> * The |settings_max_dynamic_table_size| should be the value</span>
<span class="cm"> * transmitted in SETTINGS_HEADER_TABLE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must not be called while header block is being</span>
<span class="cm"> * inflated.  In other words, this function must be called after</span>
<span class="cm"> * initialization of |inflater|, but before calling</span>
<span class="cm"> * `nghttp2_hd_inflate_hd2()`, or after</span>
<span class="cm"> * `nghttp2_hd_inflate_end_headers()`.  Otherwise,</span>
<span class="cm"> * `NGHTTP2_ERR_INVALID_STATE` was returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`</span>
<span class="cm"> *     The function is called while header block is being inflated.</span>
<span class="cm"> *     Probably, application missed to call</span>
<span class="cm"> *     `nghttp2_hd_inflate_end_headers()`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_hd_inflate_change_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span>
                                     <span class="kt">size_t</span> <span class="n">settings_max_dynamic_table_size</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for header inflation.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates all headers were inflated.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_FINAL</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates a header was emitted.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HD_INFLATE_EMIT</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="p">}</span> <span class="n">nghttp2_hd_inflate_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * .. warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Deprecated.  Use `nghttp2_hd_inflate_hd2()` instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Inflates name/value block stored in |in| with length |inlen|.  This</span>
<span class="cm"> * function performs decompression.  For each successful emission of</span>
<span class="cm"> * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in</span>
<span class="cm"> * |*inflate_flags| and name/value pair is assigned to the |nv_out|</span>
<span class="cm"> * and the function returns.  The caller must not free the members of</span>
<span class="cm"> * |nv_out|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nv_out| may include pointers to the memory region in the |in|.</span>
<span class="cm"> * The caller must retain the |in| while the |nv_out| is used.</span>
<span class="cm"> *</span>
<span class="cm"> * The application should call this function repeatedly until the</span>
<span class="cm"> * ``(*inflate_flags) &amp; NGHTTP2_HD_INFLATE_FINAL`` is nonzero and</span>
<span class="cm"> * return value is non-negative.  This means the all input values are</span>
<span class="cm"> * processed successfully.  Then the application must call</span>
<span class="cm"> * `nghttp2_hd_inflate_end_headers()` to prepare for the next header</span>
<span class="cm"> * block input.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller can feed complete compressed header block.  It also can</span>
<span class="cm"> * feed it in several chunks.  The caller must set |in_final| to</span>
<span class="cm"> * nonzero if the given input is the last block of the compressed</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes processed if it succeeds,</span>
<span class="cm"> * or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Inflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BUFFER_ERROR`</span>
<span class="cm"> *     The header field name or value is too large.</span>
<span class="cm"> *</span>
<span class="cm"> * Example follows::</span>
<span class="cm"> *</span>
<span class="cm"> *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,</span>
<span class="cm"> *                              uint8_t *in, size_t inlen, int final)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         ssize_t rv;</span>
<span class="cm"> *</span>
<span class="cm"> *         for(;;) {</span>
<span class="cm"> *             nghttp2_nv nv;</span>
<span class="cm"> *             int inflate_flags = 0;</span>
<span class="cm"> *</span>
<span class="cm"> *             rv = nghttp2_hd_inflate_hd(hd_inflater, &amp;nv, &amp;inflate_flags,</span>
<span class="cm"> *                                        in, inlen, final);</span>
<span class="cm"> *</span>
<span class="cm"> *             if(rv &lt; 0) {</span>
<span class="cm"> *                 fprintf(stderr, &quot;inflate failed with error code %zd&quot;, rv);</span>
<span class="cm"> *                 return -1;</span>
<span class="cm"> *             }</span>
<span class="cm"> *</span>
<span class="cm"> *             in += rv;</span>
<span class="cm"> *             inlen -= rv;</span>
<span class="cm"> *</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) {</span>
<span class="cm"> *                 fwrite(nv.name, nv.namelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;: &quot;);</span>
<span class="cm"> *                 fwrite(nv.value, nv.valuelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;\n&quot;);</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_FINAL) {</span>
<span class="cm"> *                 nghttp2_hd_inflate_end_headers(hd_inflater);</span>
<span class="cm"> *                 break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if((inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) == 0 &amp;&amp;</span>
<span class="cm"> *                inlen == 0) {</span>
<span class="cm"> *                break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *         }</span>
<span class="cm"> *</span>
<span class="cm"> *         return 0;</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_inflate_hd</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span>
                                             <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nv_out</span><span class="p">,</span>
                                             <span class="kt">int</span> <span class="o">*</span><span class="n">inflate_flags</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                             <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_final</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Inflates name/value block stored in |in| with length |inlen|.  This</span>
<span class="cm"> * function performs decompression.  For each successful emission of</span>
<span class="cm"> * header name/value pair, :enum:`NGHTTP2_HD_INFLATE_EMIT` is set in</span>
<span class="cm"> * |*inflate_flags| and name/value pair is assigned to the |nv_out|</span>
<span class="cm"> * and the function returns.  The caller must not free the members of</span>
<span class="cm"> * |nv_out|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nv_out| may include pointers to the memory region in the |in|.</span>
<span class="cm"> * The caller must retain the |in| while the |nv_out| is used.</span>
<span class="cm"> *</span>
<span class="cm"> * The application should call this function repeatedly until the</span>
<span class="cm"> * ``(*inflate_flags) &amp; NGHTTP2_HD_INFLATE_FINAL`` is nonzero and</span>
<span class="cm"> * return value is non-negative.  If that happens, all given input</span>
<span class="cm"> * data (|inlen| bytes) are processed successfully.  Then the</span>
<span class="cm"> * application must call `nghttp2_hd_inflate_end_headers()` to prepare</span>
<span class="cm"> * for the next header block input.</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, if |in_final| is nonzero, and this function returns</span>
<span class="cm"> * |inlen|, you can assert that :enum:`NGHTTP2_HD_INFLATE_FINAL` is</span>
<span class="cm"> * set in |*inflate_flags|.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller can feed complete compressed header block.  It also can</span>
<span class="cm"> * feed it in several chunks.  The caller must set |in_final| to</span>
<span class="cm"> * nonzero if the given input is the last block of the compressed</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes processed if it succeeds,</span>
<span class="cm"> * or one of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_HEADER_COMP`</span>
<span class="cm"> *     Inflation process has failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_BUFFER_ERROR`</span>
<span class="cm"> *     The header field name or value is too large.</span>
<span class="cm"> *</span>
<span class="cm"> * Example follows::</span>
<span class="cm"> *</span>
<span class="cm"> *     int inflate_header_block(nghttp2_hd_inflater *hd_inflater,</span>
<span class="cm"> *                              uint8_t *in, size_t inlen, int final)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         ssize_t rv;</span>
<span class="cm"> *</span>
<span class="cm"> *         for(;;) {</span>
<span class="cm"> *             nghttp2_nv nv;</span>
<span class="cm"> *             int inflate_flags = 0;</span>
<span class="cm"> *</span>
<span class="cm"> *             rv = nghttp2_hd_inflate_hd2(hd_inflater, &amp;nv, &amp;inflate_flags,</span>
<span class="cm"> *                                         in, inlen, final);</span>
<span class="cm"> *</span>
<span class="cm"> *             if(rv &lt; 0) {</span>
<span class="cm"> *                 fprintf(stderr, &quot;inflate failed with error code %zd&quot;, rv);</span>
<span class="cm"> *                 return -1;</span>
<span class="cm"> *             }</span>
<span class="cm"> *</span>
<span class="cm"> *             in += rv;</span>
<span class="cm"> *             inlen -= rv;</span>
<span class="cm"> *</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) {</span>
<span class="cm"> *                 fwrite(nv.name, nv.namelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;: &quot;);</span>
<span class="cm"> *                 fwrite(nv.value, nv.valuelen, 1, stderr);</span>
<span class="cm"> *                 fprintf(stderr, &quot;\n&quot;);</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if(inflate_flags &amp; NGHTTP2_HD_INFLATE_FINAL) {</span>
<span class="cm"> *                 nghttp2_hd_inflate_end_headers(hd_inflater);</span>
<span class="cm"> *                 break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *             if((inflate_flags &amp; NGHTTP2_HD_INFLATE_EMIT) == 0 &amp;&amp;</span>
<span class="cm"> *                inlen == 0) {</span>
<span class="cm"> *                break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *         }</span>
<span class="cm"> *</span>
<span class="cm"> *         return 0;</span>
<span class="cm"> *     }</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">ssize_t</span> <span class="nf">nghttp2_hd_inflate_hd2</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span>
                                              <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nv_out</span><span class="p">,</span>
                                              <span class="kt">int</span> <span class="o">*</span><span class="n">inflate_flags</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span>
                                              <span class="kt">int</span> <span class="n">in_final</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the end of decompression for one header block.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds. Currently this function</span>
<span class="cm"> * always succeeds.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int</span>
<span class="nf">nghttp2_hd_inflate_end_headers</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of entries that header table of |inflater|</span>
<span class="cm"> * contains.  This is the sum of the number of static table and</span>
<span class="cm"> * dynamic table, so the return value is at least 61.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_hd_inflate_get_num_table_entries</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the table entry denoted by |idx| from header table of</span>
<span class="cm"> * |inflater|.  The |idx| is 1-based, and idx=1 returns first entry of</span>
<span class="cm"> * static table.  idx=62 returns first entry of dynamic table if it</span>
<span class="cm"> * exists.  Specifying idx=0 is error, and this function returns NULL.</span>
<span class="cm"> * If |idx| is strictly greater than the number of entries the tables</span>
<span class="cm"> * contain, this function returns NULL.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span>
<span class="nf">nghttp2_hd_inflate_get_table_entry</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the used dynamic table size, including the overhead 32</span>
<span class="cm"> * bytes per entry described in RFC 7541.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_hd_inflate_get_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the maximum dynamic table size.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span>
<span class="kt">size_t</span>
<span class="nf">nghttp2_hd_inflate_get_max_dynamic_table_size</span><span class="p">(</span><span class="n">nghttp2_hd_inflater</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The structure to represent HTTP/2 stream.  The details of this</span>
<span class="cm"> * structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_stream</span> <span class="n">nghttp2_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to :type:`nghttp2_stream` object denoted by</span>
<span class="cm"> * |stream_id|.  If stream was not found, returns NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns imaginary root stream (see</span>
<span class="cm"> * `nghttp2_session_get_root_stream()`) if 0 is given in |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless |stream_id| == 0, the returned pointer is valid until next</span>
<span class="cm"> * call of `nghttp2_session_send()`, `nghttp2_session_mem_send()`,</span>
<span class="cm"> * `nghttp2_session_recv()`, and `nghttp2_session_mem_recv()`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_session_find_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * State of stream as described in RFC 7540.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * idle state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_IDLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * open state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_OPEN</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * reserved (local) state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_RESERVED_LOCAL</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * reserved (remote) state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_RESERVED_REMOTE</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * half closed (local) state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * half closed (remote) state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * closed state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_STATE_CLOSED</span>
<span class="p">}</span> <span class="n">nghttp2_stream_proto_state</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns state of |stream|.  The root stream retrieved by</span>
<span class="cm"> * `nghttp2_session_get_root_stream()` will have stream state</span>
<span class="cm"> * :enum:`NGHTTP2_STREAM_STATE_IDLE`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream_proto_state</span>
<span class="nf">nghttp2_stream_get_state</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns root of dependency tree, which is imaginary stream with</span>
<span class="cm"> * stream ID 0.  The returned pointer is valid until |session| is</span>
<span class="cm"> * freed by `nghttp2_session_del()`.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_session_get_root_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the parent stream of |stream| in dependency tree.  Returns</span>
<span class="cm"> * NULL if there is no such stream.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_stream_get_parent</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_stream_get_stream_id</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the next sibling stream of |stream| in dependency tree.</span>
<span class="cm"> * Returns NULL if there is no such stream.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_stream_get_next_sibling</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the previous sibling stream of |stream| in dependency tree.</span>
<span class="cm"> * Returns NULL if there is no such stream.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_stream_get_previous_sibling</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the first child stream of |stream| in dependency tree.</span>
<span class="cm"> * Returns NULL if there is no such stream.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="n">nghttp2_stream</span> <span class="o">*</span>
<span class="nf">nghttp2_stream_get_first_child</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns dependency weight to the parent stream of |stream|.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span> <span class="nf">nghttp2_stream_get_weight</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the sum of the weight for |stream|&#39;s children.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">int32_t</span>
<span class="nf">nghttp2_stream_get_sum_dependency_weight</span><span class="p">(</span><span class="n">nghttp2_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library outputs debug logging.</span>
<span class="cm"> * The function is called with arguments suitable for ``vfprintf(3)``</span>
<span class="cm"> *</span>
<span class="cm"> * The debug output is only enabled if the library is built with</span>
<span class="cm"> * ``DEBUGBUILD`` macro defined.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_debug_vprintf_callback</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span>
                                               <span class="kt">va_list</span> <span class="n">args</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets a debug output callback called by the library when built with</span>
<span class="cm"> * ``DEBUGBUILD`` macro defined.  If this option is not used, debug</span>
<span class="cm"> * log is written into standard error output.</span>
<span class="cm"> *</span>
<span class="cm"> * For builds without ``DEBUGBUILD`` macro defined, this function is</span>
<span class="cm"> * noop.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that building with ``DEBUGBUILD`` may cause significant</span>
<span class="cm"> * performance penalty to libnghttp2 because of extra processing.  It</span>
<span class="cm"> * should be used for debugging purpose only.</span>
<span class="cm"> *</span>
<span class="cm"> * .. Warning::</span>
<span class="cm"> *</span>
<span class="cm"> *   Building with ``DEBUGBUILD`` may cause significant performance</span>
<span class="cm"> *   penalty to libnghttp2 because of extra processing.  It should be</span>
<span class="cm"> *   used for debugging purpose only.  We write this two times because</span>
<span class="cm"> *   this is important.</span>
<span class="cm"> */</span>
<span class="n">NGHTTP2_EXTERN</span> <span class="kt">void</span> <span class="nf">nghttp2_set_debug_vprintf_callback</span><span class="p">(</span>
    <span class="n">nghttp2_debug_vprintf_callback</span> <span class="n">debug_vprintf_callback</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* NGHTTP2_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nghttp2ver.h.html" class="btn btn-neutral float-right" title="nghttp2ver.h" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="python-apiref.html" class="btn btn-neutral" title="Python API Reference" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, 2015, 2016, Tatsuhiro Tsujikawa.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.22.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>