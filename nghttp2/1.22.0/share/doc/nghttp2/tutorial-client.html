

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial: HTTP/2 client &mdash; nghttp2 1.22.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="nghttp2 1.22.0 documentation" href="index.html"/>
        <link rel="next" title="Tutorial: HTTP/2 server" href="tutorial-server.html"/>
        <link rel="prev" title="Building Android binary" href="building-android-binary.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> nghttp2
          

          
          </a>

          
            
            
              <div class="version">
                1.22.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="package_README.html">nghttp2 - HTTP/2 C Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="building-android-binary.html">Building Android binary</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: HTTP/2 client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#libevent-client-c">libevent-client.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-server.html">Tutorial: HTTP/2 server</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-hpack.html">Tutorial: HPACK API</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp.1.html">nghttp(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpd.1.html">nghttpd(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx.1.html">nghttpx(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="h2load.1.html">h2load(1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx-howto.html">nghttpx - HTTP/2 proxy - HOW-TO</a></li>
<li class="toctree-l1"><a class="reference internal" href="h2load-howto.html">h2load - HTTP/2 benchmarking tool - HOW-TO</a></li>
<li class="toctree-l1"><a class="reference internal" href="programmers-guide.html">Programmers' Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="libnghttp2_asio.html">libnghttp2_asio: High level HTTP/2 C++ library</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-apiref.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp2.h.html">nghttp2.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp2ver.h.html">nghttp2ver.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_server.h.html">asio_http2_server.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2_client.h.html">asio_http2_client.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="asio_http2.h.html">asio_http2.h</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nghttp2/nghttp2">Source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nghttp2/nghttp2/issues">Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://nghttp2.org/">nghttp2.org</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">nghttp2</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Tutorial: HTTP/2 client</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial-http-2-client">
<h1>Tutorial: HTTP/2 client<a class="headerlink" href="#tutorial-http-2-client" title="Permalink to this headline">Â¶</a></h1>
<p>In this tutorial, we are going to write a very primitive HTTP/2
client. The complete source code, <a class="reference internal" href="#libevent-client-c">libevent-client.c</a>, is attached at
the end of this page.  It also resides in the examples directory in
the archive or repository.</p>
<p>This simple client takes a single HTTPS URI and retrieves the resource
at the URI. The synopsis is:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>$ libevent-client HTTPS_URI
</pre></div>
</div>
<p>We use libevent in this tutorial to handle networking I/O.  Please
note that nghttp2 itself does not depend on libevent.</p>
<p>The client starts with some libevent and OpenSSL setup in the
<code class="docutils literal"><span class="pre">main()</span></code> and <code class="docutils literal"><span class="pre">run()</span></code> functions. This setup isn't specific to
nghttp2, but one thing you should look at is setup of the NPN
callback.  The NPN callback is used by the client to select the next
application protocol over TLS. In this tutorial, we use the
<a class="reference internal" href="nghttp2_select_next_protocol.html#c.nghttp2_select_next_protocol" title="nghttp2_select_next_protocol"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_select_next_protocol()</span></code></a> helper function to select the HTTP/2
protocol the library supports:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_next_proto_cb</span><span class="p">(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="n">_U_</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nghttp2_select_next_protocol</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">outlen</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">inlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Server did not advertise &quot;</span> <span class="n">NGHTTP2_PROTO_VERSION_ID</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SSL_TLSEXT_ERR_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you are following TLS related RFC, you know that NPN is not the
standardized way to negotiate HTTP/2.  NPN itself is not event
published as RFC.  The standard way to negotiate HTTP/2 is ALPN,
Application-Layer Protocol Negotiation Extension, defined in <a class="reference external" href="https://tools.ietf.org/html/rfc7301">RFC 7301</a>.  The one caveat of ALPN is
that OpenSSL &gt;= 1.0.2 is required.  We use macro to enable/disable
ALPN support depending on OpenSSL version.  OpenSSL's ALPN
implementation does not require callback function like the above.  But
we have to instruct OpenSSL SSL_CTX to use ALPN, which we'll talk
about soon.</p>
<p>The callback is added to the SSL_CTX object using
<code class="docutils literal"><span class="pre">SSL_CTX_set_next_proto_select_cb()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="nf">create_ssl_ctx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">;</span>
  <span class="n">ssl_ctx</span> <span class="o">=</span> <span class="n">SSL_CTX_new</span><span class="p">(</span><span class="n">SSLv23_client_method</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssl_ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not create SSL/TLS context: %s&quot;</span><span class="p">,</span>
         <span class="n">ERR_error_string</span><span class="p">(</span><span class="n">ERR_get_error</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">SSL_CTX_set_options</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span>
                      <span class="n">SSL_OP_ALL</span> <span class="o">|</span> <span class="n">SSL_OP_NO_SSLv2</span> <span class="o">|</span> <span class="n">SSL_OP_NO_SSLv3</span> <span class="o">|</span>
                          <span class="n">SSL_OP_NO_COMPRESSION</span> <span class="o">|</span>
                          <span class="n">SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION</span><span class="p">);</span>
  <span class="n">SSL_CTX_set_next_proto_select_cb</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span> <span class="n">select_next_proto_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#if OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>
  <span class="n">SSL_CTX_set_alpn_protos</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;</span><span class="se">\x02</span><span class="s">h2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>

  <span class="k">return</span> <span class="n">ssl_ctx</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we see <code class="docutils literal"><span class="pre">SSL_CTX_get_alpn_protos()</span></code> function call.  We instructs
OpenSSL to notify the server that we support h2, ALPN identifier for
HTTP/2.</p>
<p>The example client defines a couple of structs:</p>
<p>We define and use a <code class="docutils literal"><span class="pre">http2_session_data</span></code> structure to store data
related to the HTTP/2 session:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">evdns_base</span> <span class="o">*</span><span class="n">dnsbase</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">;</span>
  <span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">http2_session_data</span><span class="p">;</span>
</pre></div>
</div>
<p>Since this program only handles one URI, it uses only one stream. We
store the single stream's data in a <code class="docutils literal"><span class="pre">http2_stream_data</span></code> structure
and the <code class="docutils literal"><span class="pre">stream_data</span></code> points to it. The <code class="docutils literal"><span class="pre">http2_stream_data</span></code>
structure is defined as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/* The NULL-terminated URI string to retrieve. */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">;</span>
  <span class="cm">/* Parsed result of the |uri| */</span>
  <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
  <span class="cm">/* The authority portion of the |uri|, not NULL-terminated */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">authority</span><span class="p">;</span>
  <span class="cm">/* The path portion of the |uri|, including query, not</span>
<span class="cm">     NULL-terminated */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
  <span class="cm">/* The length of the |authority| */</span>
  <span class="kt">size_t</span> <span class="n">authoritylen</span><span class="p">;</span>
  <span class="cm">/* The length of the |path| */</span>
  <span class="kt">size_t</span> <span class="n">pathlen</span><span class="p">;</span>
  <span class="cm">/* The stream ID of this stream */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">http2_stream_data</span><span class="p">;</span>
</pre></div>
</div>
<p>We create and initialize these structures in
<code class="docutils literal"><span class="pre">create_http2_session_data()</span></code> and <code class="docutils literal"><span class="pre">create_http2_stream_data()</span></code>
respectively.</p>
<p><code class="docutils literal"><span class="pre">initiate_connection()</span></code> is called to start the connection to the
remote server. It's defined as:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">initiate_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">evbase</span><span class="p">,</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span>
                                <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">;</span>
  <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>

  <span class="n">ssl</span> <span class="o">=</span> <span class="n">create_ssl</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">);</span>
  <span class="n">bev</span> <span class="o">=</span> <span class="n">bufferevent_openssl_socket_new</span><span class="p">(</span>
      <span class="n">evbase</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ssl</span><span class="p">,</span> <span class="n">BUFFEREVENT_SSL_CONNECTING</span><span class="p">,</span>
      <span class="n">BEV_OPT_DEFER_CALLBACKS</span> <span class="o">|</span> <span class="n">BEV_OPT_CLOSE_ON_FREE</span><span class="p">);</span>
  <span class="n">bufferevent_setcb</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">readcb</span><span class="p">,</span> <span class="n">writecb</span><span class="p">,</span> <span class="n">eventcb</span><span class="p">,</span> <span class="n">session_data</span><span class="p">);</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">bufferevent_socket_connect_hostname</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">dnsbase</span><span class="p">,</span>
                                           <span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not connect to the remote host %s&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span> <span class="o">=</span> <span class="n">bev</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">initiate_connection()</span></code> creates a bufferevent for the connection and
sets up three callbacks: <code class="docutils literal"><span class="pre">readcb</span></code>, <code class="docutils literal"><span class="pre">writecb</span></code>, and <code class="docutils literal"><span class="pre">eventcb</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">eventcb()</span></code> is invoked by the libevent event loop when an event
(e.g. connection has been established, timeout, etc.) occurs on the
underlying network socket:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">eventcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">bufferevent_getfd</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alpnlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">ssl</span> <span class="o">=</span> <span class="n">bufferevent_openssl_get_ssl</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">);</span>

    <span class="n">SSL_get0_next_proto_negotiated</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpnlen</span><span class="p">);</span>
<span class="cp">#if OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alpn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SSL_get0_alpn_selected</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpnlen</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpn</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">alpnlen</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;h2&quot;</span><span class="p">,</span> <span class="n">alpn</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;h2 is not negotiated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="n">initialize_nghttp2_session</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="n">send_client_connection_header</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="n">submit_request</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">session_send</span><span class="p">(</span><span class="n">session_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Disconnected from the remote host&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_ERROR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Network error&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Timeout&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we validate that HTTP/2 is negotiated, and if not, drop
connection.</p>
<p>For <code class="docutils literal"><span class="pre">BEV_EVENT_EOF</span></code>, <code class="docutils literal"><span class="pre">BEV_EVENT_ERROR</span></code>, and <code class="docutils literal"><span class="pre">BEV_EVENT_TIMEOUT</span></code>
events, we just simply tear down the connection.</p>
<p>The <code class="docutils literal"><span class="pre">BEV_EVENT_CONNECTED</span></code> event is invoked when the SSL/TLS
handshake has completed successfully. After this we're ready to begin
communicating via HTTP/2.</p>
<p>The <code class="docutils literal"><span class="pre">initialize_nghttp2_session()</span></code> function initializes the nghttp2
session object and several callbacks:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">initialize_nghttp2_session</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">;</span>

  <span class="n">nghttp2_session_callbacks_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbacks</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_send_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">send_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_frame_recv_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span>
                                                       <span class="n">on_frame_recv_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_data_chunk_recv_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_data_chunk_recv_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_stream_close_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_stream_close_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_header_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span>
                                                   <span class="n">on_header_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_begin_headers_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_begin_headers_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_client_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">session_data</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_del</span><span class="p">(</span><span class="n">callbacks</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since we are creating a client, we use <a class="reference internal" href="nghttp2_session_client_new.html#c.nghttp2_session_client_new" title="nghttp2_session_client_new"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_client_new()</span></code></a>
to initialize the nghttp2 session object.  The callbacks setup are
explained later.</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">delete_http2_session_data()</span></code> function destroys <code class="docutils literal"><span class="pre">session_data</span></code>
and frees its bufferevent, so the underlying connection is closed. It
also calls <a class="reference internal" href="nghttp2_session_del.html#c.nghttp2_session_del" title="nghttp2_session_del"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_del()</span></code></a> to delete the nghttp2 session
object.</p>
<p>A HTTP/2 connection begins by sending the client connection preface,
which is a 24 byte magic byte string (<a class="reference internal" href="macros.html#c.NGHTTP2_CLIENT_MAGIC" title="NGHTTP2_CLIENT_MAGIC"><code class="xref c c-macro docutils literal"><span class="pre">NGHTTP2_CLIENT_MAGIC</span></code></a>),
followed by a SETTINGS frame. The 24 byte magic string is sent
automatically by nghttp2. We send the SETTINGS frame in
<code class="docutils literal"><span class="pre">send_client_connection_header()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">send_client_connection_header</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">nghttp2_settings_entry</span> <span class="n">iv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="n">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS</span><span class="p">,</span> <span class="mi">100</span><span class="p">}};</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="cm">/* client 24 bytes magic string will be sent by nghttp2 library */</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_submit_settings</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">NGHTTP2_FLAG_NONE</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span>
                               <span class="n">ARRLEN</span><span class="p">(</span><span class="n">iv</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not submit SETTINGS: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">rv</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we specify SETTINGS_MAX_CONCURRENT_STREAMS as 100. This is not
needed for this tiny example program, it just demonstrates use of the
SETTINGS frame. To queue the SETTINGS frame for transmission, we call
<a class="reference internal" href="nghttp2_submit_settings.html#c.nghttp2_submit_settings" title="nghttp2_submit_settings"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_submit_settings()</span></code></a>. Note that <a class="reference internal" href="nghttp2_submit_settings.html#c.nghttp2_submit_settings" title="nghttp2_submit_settings"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_submit_settings()</span></code></a>
only queues the frame for transmission, and doesn't actually send it.
All <code class="docutils literal"><span class="pre">nghttp2_submit_*()</span></code> family functions have this property. To
actually send the frame, <a class="reference internal" href="nghttp2_session_send.html#c.nghttp2_session_send" title="nghttp2_session_send"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_send()</span></code></a> has to be called,
which is described (and called) later.</p>
<p>After the transmission of the client connection header, we enqueue the
HTTP request in the <code class="docutils literal"><span class="pre">submit_request()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">submit_request</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span> <span class="o">=</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span> <span class="o">=</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">uri</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">;</span>
  <span class="n">nghttp2_nv</span> <span class="n">hdrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">MAKE_NV2</span><span class="p">(</span><span class="s">&quot;:method&quot;</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:scheme&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_SCHEMA</span><span class="p">].</span><span class="n">off</span><span class="p">],</span>
              <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_SCHEMA</span><span class="p">].</span><span class="n">len</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:authority&quot;</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authoritylen</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:path&quot;</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span><span class="p">)};</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Request headers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">print_headers</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">hdrs</span><span class="p">,</span> <span class="n">ARRLEN</span><span class="p">(</span><span class="n">hdrs</span><span class="p">));</span>
  <span class="n">stream_id</span> <span class="o">=</span> <span class="n">nghttp2_submit_request</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hdrs</span><span class="p">,</span>
                                     <span class="n">ARRLEN</span><span class="p">(</span><span class="n">hdrs</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">stream_data</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not submit HTTP request: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">stream_id</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">=</span> <span class="n">stream_id</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We build the HTTP request header fields in <code class="docutils literal"><span class="pre">hdrs</span></code>, which is an array
of <a class="reference internal" href="types.html#c.nghttp2_nv" title="nghttp2_nv"><code class="xref c c-type docutils literal"><span class="pre">nghttp2_nv</span></code></a>. There are four header fields to be sent:
<code class="docutils literal"><span class="pre">:method</span></code>, <code class="docutils literal"><span class="pre">:scheme</span></code>, <code class="docutils literal"><span class="pre">:authority</span></code>, and <code class="docutils literal"><span class="pre">:path</span></code>. To queue the
HTTP request, we call <a class="reference internal" href="nghttp2_submit_request.html#c.nghttp2_submit_request" title="nghttp2_submit_request"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_submit_request()</span></code></a>. The <code class="docutils literal"><span class="pre">stream_data</span></code>
is passed via the <em>stream_user_data</em> parameter, which is helpfully
later passed back to callback functions.</p>
<p><a class="reference internal" href="nghttp2_submit_request.html#c.nghttp2_submit_request" title="nghttp2_submit_request"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_submit_request()</span></code></a> returns the newly assigned stream ID for
the request.</p>
<p>The next bufferevent callback is <code class="docutils literal"><span class="pre">readcb()</span></code>, which is invoked when
data is available to read from the bufferevent input buffer:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">readcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">readlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">evbuffer</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">bufferevent_get_input</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">datalen</span> <span class="o">=</span> <span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">evbuffer_pullup</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">readlen</span> <span class="o">=</span> <span class="n">nghttp2_session_mem_recv</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">readlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">readlen</span><span class="p">));</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_drain</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">readlen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: evbuffer_drain failed&quot;</span><span class="p">);</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">session_send</span><span class="p">(</span><span class="n">session_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this function we feed all unprocessed, received data to the nghttp2
session object using the <a class="reference internal" href="nghttp2_session_mem_recv.html#c.nghttp2_session_mem_recv" title="nghttp2_session_mem_recv"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_mem_recv()</span></code></a> function.
<a class="reference internal" href="nghttp2_session_mem_recv.html#c.nghttp2_session_mem_recv" title="nghttp2_session_mem_recv"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_mem_recv()</span></code></a> processes the received data and may
invoke nghttp2 callbacks and queue frames for transmission.  Since
there may be pending frames for transmission, we call immediately
<code class="docutils literal"><span class="pre">session_send()</span></code> to send them.  <code class="docutils literal"><span class="pre">session_send()</span></code> is defined as
follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">session_send</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_session_send</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">rv</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="nghttp2_session_send.html#c.nghttp2_session_send" title="nghttp2_session_send"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_send()</span></code></a> function serializes pending frames into
wire format and calls the <code class="docutils literal"><span class="pre">send_callback()</span></code> function to send them.
<code class="docutils literal"><span class="pre">send_callback()</span></code> has type <a class="reference internal" href="types.html#c.nghttp2_send_callback" title="nghttp2_send_callback"><code class="xref c c-type docutils literal"><span class="pre">nghttp2_send_callback</span></code></a> and is
defined as:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">send_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span> <span class="n">_U_</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span> <span class="o">=</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">;</span>
  <span class="n">bufferevent_write</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since we use bufferevent to abstract network I/O, we just write the
data to the bufferevent object. Note that <a class="reference internal" href="nghttp2_session_send.html#c.nghttp2_session_send" title="nghttp2_session_send"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_send()</span></code></a>
continues to write all frames queued so far. If we were writing the
data to the non-blocking socket directly using the <code class="docutils literal"><span class="pre">write()</span></code> system
call, we'd soon receive an <code class="docutils literal"><span class="pre">EAGAIN</span></code> or <code class="docutils literal"><span class="pre">EWOULDBLOCK</span></code> error, since
sockets have a limited send buffer. If that happens, it's possible to
return <a class="reference internal" href="enums.html#c.NGHTTP2_ERR_WOULDBLOCK" title="NGHTTP2_ERR_WOULDBLOCK"><code class="xref c c-macro docutils literal"><span class="pre">NGHTTP2_ERR_WOULDBLOCK</span></code></a> to signal the nghttp2 library
to stop sending further data. When writing to a bufferevent, you
should regulate the amount of data written, to avoid possible huge
memory consumption. In this example client however we don't implement
a limit. To see how to regulate the amount of buffered data, see the
<code class="docutils literal"><span class="pre">send_callback()</span></code> in the server tutorial.</p>
<p>The third bufferevent callback is <code class="docutils literal"><span class="pre">writecb()</span></code>, which is invoked when
all data written in the bufferevent output buffer has been sent:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">writecb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nghttp2_session_want_read</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">nghttp2_session_want_write</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">bufferevent_get_output</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As described earlier, we just write off all data in <code class="xref c c-func docutils literal"><span class="pre">send_callback()</span></code>,
so there is no data to write in this function. All we have to do is
check if the connection should be dropped or not. The nghttp2 session
object keeps track of reception and transmission of GOAWAY frames and
other error conditions. Using this information, the nghttp2 session
object can state whether the connection should be dropped or not.
More specifically, when both <a class="reference internal" href="nghttp2_session_want_read.html#c.nghttp2_session_want_read" title="nghttp2_session_want_read"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_want_read()</span></code></a> and
<a class="reference internal" href="nghttp2_session_want_write.html#c.nghttp2_session_want_write" title="nghttp2_session_want_write"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_want_write()</span></code></a> return 0, the connection is no-longer
required and can be closed. Since we're using bufferevent and its
deferred callback option, the bufferevent output buffer may still
contain pending data when the <code class="docutils literal"><span class="pre">writecb()</span></code> is called. To handle this
situation, we also check whether the output buffer is empty or not. If
all of these conditions are met, then we drop the connection.</p>
<p>Now let's look at the remaining nghttp2 callbacks setup in the
<code class="docutils literal"><span class="pre">initialize_nghttp2_setup()</span></code> function.</p>
<p>A server responds to the request by first sending a HEADERS frame.
The HEADERS frame consists of response header name/value pairs, and
the <code class="docutils literal"><span class="pre">on_header_callback()</span></code> is called for each name/value pair:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">on_header_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span> <span class="n">_U_</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span> <span class="n">_U_</span><span class="p">,</span>
                              <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">NGHTTP2_HEADERS</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">cat</span> <span class="o">==</span> <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">&amp;&amp;</span>
        <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* Print response headers for the initiated request. */</span>
      <span class="n">print_header</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this tutorial, we just print the name/value pairs on stdout.</p>
<p>After the HEADERS frame has been fully received (and thus all response
header name/value pairs have been received), the
<code class="docutils literal"><span class="pre">on_frame_recv_callback()</span></code> function is called:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">on_frame_recv_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span> <span class="n">_U_</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">NGHTTP2_HEADERS</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">cat</span> <span class="o">==</span> <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">&amp;&amp;</span>
        <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;All headers received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">on_frame_recv_callback()</span></code> is called for other frame types too.</p>
<p>In this tutorial, we are just interested in the HTTP response HEADERS
frame. We check the frame type and its category (it should be
<a class="reference internal" href="enums.html#c.NGHTTP2_HCAT_RESPONSE" title="NGHTTP2_HCAT_RESPONSE"><code class="xref c c-macro docutils literal"><span class="pre">NGHTTP2_HCAT_RESPONSE</span></code></a> for HTTP response HEADERS). We also
check its stream ID.</p>
<p>Next, zero or more DATA frames can be received. The
<code class="docutils literal"><span class="pre">on_data_chunk_recv_callback()</span></code> function is invoked when a chunk of
data is received from the remote peer:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">on_data_chunk_recv_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span> <span class="n">_U_</span><span class="p">,</span>
                                       <span class="kt">uint8_t</span> <span class="n">flags</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
                                       <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In our case, a chunk of data is HTTP response body. After checking the
stream ID, we just write the received data to stdout. Note the output
in the terminal may be corrupted if the response body contains some
binary data.</p>
<p>The <code class="docutils literal"><span class="pre">on_stream_close_callback()</span></code> function is invoked when the stream
is about to close:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">on_stream_close_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                    <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">,</span>
                                    <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Stream %d closed with error_code=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span>
            <span class="n">error_code</span><span class="p">);</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_session_terminate_session</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">NGHTTP2_NO_ERROR</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">NGHTTP2_ERR_CALLBACK_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the stream ID matches the one we initiated, it means that its
stream is going to be closed. Since we have finished receiving
resource we wanted (or the stream was reset by RST_STREAM from the
remote peer), we call <a class="reference internal" href="nghttp2_session_terminate_session.html#c.nghttp2_session_terminate_session" title="nghttp2_session_terminate_session"><code class="xref c c-func docutils literal"><span class="pre">nghttp2_session_terminate_session()</span></code></a> to
commence closure of the HTTP/2 session gracefully. If you have
some data associated for the stream to be closed, you may delete it
here.</p>
<div class="section" id="libevent-client-c">
<h2>libevent-client.c<a class="headerlink" href="#libevent-client-c" title="Permalink to this headline">Â¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * nghttp2 - HTTP/2 C Library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2013 Tatsuhiro Tsujikawa</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="cm"> * a copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __sgi</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#define errx(exitcode, format, args...)                                        \</span>
<span class="cp">  {                                                                            \</span>
<span class="cp">    warnx(format, ##args);                                                     \</span>
<span class="cp">    exit(exitcode);                                                            \</span>
<span class="cp">  }</span>
<span class="cp">#define warnx(format, args...) fprintf(stderr, format &quot;\n&quot;, ##args)</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">strndup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef HAVE_CONFIG_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;config.h&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* HAVE_CONFIG_H */</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#ifdef HAVE_UNISTD_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* HAVE_UNISTD_H */</span><span class="cp"></span>
<span class="cp">#ifdef HAVE_SYS_SOCKET_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* HAVE_SYS_SOCKET_H */</span><span class="cp"></span>
<span class="cp">#ifdef HAVE_NETINET_IN_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* HAVE_NETINET_IN_H */</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/tcp.h&gt;</span><span class="cp"></span>
<span class="cp">#ifndef __sgi</span>
<span class="cp">#include</span> <span class="cpf">&lt;err.h&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;openssl/ssl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;openssl/err.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;openssl/conf.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;event.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;event2/event.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;event2/bufferevent_ssl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;event2/dns.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;nghttp2/nghttp2.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;http-parser/http_parser.h&quot;</span><span class="cp"></span>

<span class="cp">#define ARRLEN(x) (sizeof(x) / sizeof(x[0]))</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/* The NULL-terminated URI string to retrieve. */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">;</span>
  <span class="cm">/* Parsed result of the |uri| */</span>
  <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
  <span class="cm">/* The authority portion of the |uri|, not NULL-terminated */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">authority</span><span class="p">;</span>
  <span class="cm">/* The path portion of the |uri|, including query, not</span>
<span class="cm">     NULL-terminated */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
  <span class="cm">/* The length of the |authority| */</span>
  <span class="kt">size_t</span> <span class="n">authoritylen</span><span class="p">;</span>
  <span class="cm">/* The length of the |path| */</span>
  <span class="kt">size_t</span> <span class="n">pathlen</span><span class="p">;</span>
  <span class="cm">/* The stream ID of this stream */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">http2_stream_data</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">evdns_base</span> <span class="o">*</span><span class="n">dnsbase</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">;</span>
  <span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">http2_session_data</span><span class="p">;</span>

<span class="k">static</span> <span class="n">http2_stream_data</span> <span class="o">*</span><span class="nf">create_http2_stream_data</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span>
                                                   <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="o">*</span><span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* MAX 5 digits (max 65535) + 1 &#39;:&#39; + 1 NULL (because of snprintf) */</span>
  <span class="kt">size_t</span> <span class="n">extra</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">http2_stream_data</span><span class="p">));</span>

  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">uri</span> <span class="o">=</span> <span class="n">uri</span><span class="p">;</span>
  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authoritylen</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authoritylen</span> <span class="o">+</span> <span class="n">extra</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">off</span><span class="p">],</span>
         <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_PORT</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authoritylen</span> <span class="o">+=</span>
        <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">snprintf</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span> <span class="o">+</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">len</span><span class="p">,</span>
                         <span class="n">extra</span><span class="p">,</span> <span class="s">&quot;:%u&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* If we don&#39;t have path in URI, we use &quot;/&quot; as path. */</span>
  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_PATH</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_PATH</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_QUERY</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* +1 for &#39;?&#39; character */</span>
    <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_QUERY</span><span class="p">].</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_PATH</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_PATH</span><span class="p">].</span><span class="n">off</span><span class="p">],</span>
           <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_PATH</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_QUERY</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">[</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span> <span class="o">-</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_QUERY</span><span class="p">].</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
        <span class="sc">&#39;?&#39;</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">+</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span> <span class="o">-</span>
               <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_QUERY</span><span class="p">].</span><span class="n">len</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_QUERY</span><span class="p">].</span><span class="n">off</span><span class="p">],</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_QUERY</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">stream_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_http2_stream_data</span><span class="p">(</span><span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">free</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">stream_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initializes |session_data| */</span>
<span class="k">static</span> <span class="n">http2_session_data</span> <span class="o">*</span>
<span class="nf">create_http2_session_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">evbase</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">http2_session_data</span><span class="p">));</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">session_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">http2_session_data</span><span class="p">));</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">dnsbase</span> <span class="o">=</span> <span class="n">evdns_base_new</span><span class="p">(</span><span class="n">evbase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">session_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_http2_session_data</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span> <span class="o">=</span> <span class="n">bufferevent_openssl_get_ssl</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ssl</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SSL_shutdown</span><span class="p">(</span><span class="n">ssl</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bufferevent_free</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">);</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">evdns_base_free</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">dnsbase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">dnsbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">nghttp2_session_del</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delete_http2_stream_data</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="p">);</span>
    <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_header</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span>
                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fwrite</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;: &quot;</span><span class="p">);</span>
  <span class="n">fwrite</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Print HTTP headers to |f|. Please note that this function does not</span>
<span class="cm">   take into account that header name and value are sequence of</span>
<span class="cm">   octets, therefore they may contain non-printable characters. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_headers</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nvlen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_header</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nva</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">nva</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">namelen</span><span class="p">,</span> <span class="n">nva</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">,</span> <span class="n">nva</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valuelen</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_send_callback. Here we transmit the |data|, |length| bytes,</span>
<span class="cm">   to the network. Because we are using libevent bufferevent, we just</span>
<span class="cm">   write those bytes into bufferevent buffer. */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">send_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span> <span class="o">=</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">session</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">flags</span><span class="p">;</span>

  <span class="n">bufferevent_write</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_on_header_callback: Called when nghttp2 library emits</span>
<span class="cm">   single header name/value pair. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_header_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">session</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">flags</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">NGHTTP2_HEADERS</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">cat</span> <span class="o">==</span> <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">&amp;&amp;</span>
        <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* Print response headers for the initiated request. */</span>
      <span class="n">print_header</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valuelen</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_on_begin_headers_callback: Called when nghttp2 library gets</span>
<span class="cm">   started to receive header block. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_begin_headers_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
                                     <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">session</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">NGHTTP2_HEADERS</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">cat</span> <span class="o">==</span> <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">&amp;&amp;</span>
        <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Response headers for stream ID=%d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_on_frame_recv_callback: Called when nghttp2 library</span>
<span class="cm">   received a complete frame from the remote peer. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_frame_recv_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">session</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">NGHTTP2_HEADERS</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">headers</span><span class="p">.</span><span class="n">cat</span> <span class="o">==</span> <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">&amp;&amp;</span>
        <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">hd</span><span class="p">.</span><span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;All headers received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_on_data_chunk_recv_callback: Called when DATA frame is</span>
<span class="cm">   received from the remote peer. In this implementation, if the frame</span>
<span class="cm">   is meant to the stream we initiated, print the received data in</span>
<span class="cm">   stdout, so that the user can redirect its output to the file</span>
<span class="cm">   easily. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_data_chunk_recv_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                       <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">session</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">flags</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* nghttp2_on_stream_close_callback: Called when a stream is about to</span>
<span class="cm">   closed. This example program only deals with 1 HTTP request (1</span>
<span class="cm">   stream), if it is closed, we send GOAWAY and tear down the</span>
<span class="cm">   session */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_stream_close_callback</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                    <span class="kt">uint32_t</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">user_data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">==</span> <span class="n">stream_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Stream %d closed with error_code=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">,</span>
            <span class="n">error_code</span><span class="p">);</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_session_terminate_session</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">NGHTTP2_NO_ERROR</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">NGHTTP2_ERR_CALLBACK_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NPN TLS extension client callback. We check that server advertised</span>
<span class="cm">   the HTTP/2 protocol the nghttp2 library supports. If not, exit</span>
<span class="cm">   the program. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">select_next_proto_cb</span><span class="p">(</span><span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ssl</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">nghttp2_select_next_protocol</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">outlen</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">inlen</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Server did not advertise &quot;</span> <span class="n">NGHTTP2_PROTO_VERSION_ID</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SSL_TLSEXT_ERR_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create SSL_CTX. */</span>
<span class="k">static</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="nf">create_ssl_ctx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">;</span>
  <span class="n">ssl_ctx</span> <span class="o">=</span> <span class="n">SSL_CTX_new</span><span class="p">(</span><span class="n">SSLv23_client_method</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssl_ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not create SSL/TLS context: %s&quot;</span><span class="p">,</span>
         <span class="n">ERR_error_string</span><span class="p">(</span><span class="n">ERR_get_error</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">SSL_CTX_set_options</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span>
                      <span class="n">SSL_OP_ALL</span> <span class="o">|</span> <span class="n">SSL_OP_NO_SSLv2</span> <span class="o">|</span> <span class="n">SSL_OP_NO_SSLv3</span> <span class="o">|</span>
                          <span class="n">SSL_OP_NO_COMPRESSION</span> <span class="o">|</span>
                          <span class="n">SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION</span><span class="p">);</span>
  <span class="n">SSL_CTX_set_next_proto_select_cb</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span> <span class="n">select_next_proto_cb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cp">#if OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>
  <span class="n">SSL_CTX_set_alpn_protos</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;</span><span class="se">\x02</span><span class="s">h2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>

  <span class="k">return</span> <span class="n">ssl_ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create SSL object */</span>
<span class="k">static</span> <span class="n">SSL</span> <span class="o">*</span><span class="nf">create_ssl</span><span class="p">(</span><span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>
  <span class="n">ssl</span> <span class="o">=</span> <span class="n">SSL_new</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssl</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not create SSL/TLS session object: %s&quot;</span><span class="p">,</span>
         <span class="n">ERR_error_string</span><span class="p">(</span><span class="n">ERR_get_error</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ssl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">initialize_nghttp2_session</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">;</span>

  <span class="n">nghttp2_session_callbacks_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callbacks</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_send_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span> <span class="n">send_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_frame_recv_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span>
                                                       <span class="n">on_frame_recv_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_data_chunk_recv_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_data_chunk_recv_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_stream_close_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_stream_close_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_header_callback</span><span class="p">(</span><span class="n">callbacks</span><span class="p">,</span>
                                                   <span class="n">on_header_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_set_on_begin_headers_callback</span><span class="p">(</span>
      <span class="n">callbacks</span><span class="p">,</span> <span class="n">on_begin_headers_callback</span><span class="p">);</span>

  <span class="n">nghttp2_session_client_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">session_data</span><span class="p">);</span>

  <span class="n">nghttp2_session_callbacks_del</span><span class="p">(</span><span class="n">callbacks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_client_connection_header</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">nghttp2_settings_entry</span> <span class="n">iv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="n">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS</span><span class="p">,</span> <span class="mi">100</span><span class="p">}};</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="cm">/* client 24 bytes magic string will be sent by nghttp2 library */</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_submit_settings</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">NGHTTP2_FLAG_NONE</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span>
                               <span class="n">ARRLEN</span><span class="p">(</span><span class="n">iv</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not submit SETTINGS: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">rv</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAKE_NV(NAME, VALUE, VALUELEN)                                         \</span>
<span class="cp">  {                                                                            \</span>
<span class="cp">    (uint8_t *)NAME, (uint8_t *)VALUE, sizeof(NAME) - 1, VALUELEN,             \</span>
<span class="cp">        NGHTTP2_NV_FLAG_NONE                                                   \</span>
<span class="cp">  }</span>

<span class="cp">#define MAKE_NV2(NAME, VALUE)                                                  \</span>
<span class="cp">  {                                                                            \</span>
<span class="cp">    (uint8_t *)NAME, (uint8_t *)VALUE, sizeof(NAME) - 1, sizeof(VALUE) - 1,    \</span>
<span class="cp">        NGHTTP2_NV_FLAG_NONE                                                   \</span>
<span class="cp">  }</span>

<span class="cm">/* Send HTTP request to the remote peer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">submit_request</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="n">http2_stream_data</span> <span class="o">*</span><span class="n">stream_data</span> <span class="o">=</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span> <span class="o">=</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">uri</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">;</span>
  <span class="n">nghttp2_nv</span> <span class="n">hdrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">MAKE_NV2</span><span class="p">(</span><span class="s">&quot;:method&quot;</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:scheme&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_SCHEMA</span><span class="p">].</span><span class="n">off</span><span class="p">],</span>
              <span class="n">u</span><span class="o">-&gt;</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_SCHEMA</span><span class="p">].</span><span class="n">len</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:authority&quot;</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authority</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">authoritylen</span><span class="p">),</span>
      <span class="n">MAKE_NV</span><span class="p">(</span><span class="s">&quot;:path&quot;</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">pathlen</span><span class="p">)};</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Request headers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">print_headers</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">hdrs</span><span class="p">,</span> <span class="n">ARRLEN</span><span class="p">(</span><span class="n">hdrs</span><span class="p">));</span>
  <span class="n">stream_id</span> <span class="o">=</span> <span class="n">nghttp2_submit_request</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hdrs</span><span class="p">,</span>
                                     <span class="n">ARRLEN</span><span class="p">(</span><span class="n">hdrs</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">stream_data</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stream_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not submit HTTP request: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">stream_id</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">stream_data</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">=</span> <span class="n">stream_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Serialize the frame and send (or buffer) the data to</span>
<span class="cm">   bufferevent. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">session_send</span><span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

  <span class="n">rv</span> <span class="o">=</span> <span class="n">nghttp2_session_send</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">(</span><span class="n">rv</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* readcb for bufferevent. Here we get the data from the input buffer</span>
<span class="cm">   of bufferevent and feed them to nghttp2 library. This may invoke</span>
<span class="cm">   nghttp2 callbacks. It may also queues the frame in nghttp2 session</span>
<span class="cm">   context. To send them, we call session_send() in the end. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">readcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">readlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">evbuffer</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">bufferevent_get_input</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">datalen</span> <span class="o">=</span> <span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">evbuffer_pullup</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">readlen</span> <span class="o">=</span> <span class="n">nghttp2_session_mem_recv</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalen</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">readlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: %s&quot;</span><span class="p">,</span> <span class="n">nghttp2_strerror</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">readlen</span><span class="p">));</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">evbuffer_drain</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">readlen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Fatal error: evbuffer_drain failed&quot;</span><span class="p">);</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">session_send</span><span class="p">(</span><span class="n">session_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* writecb for bufferevent. To greaceful shutdown after sending or</span>
<span class="cm">   receiving GOAWAY, we check the some conditions on the nghttp2</span>
<span class="cm">   library and output buffer of bufferevent. If it indicates we have</span>
<span class="cm">   no business to this session, tear down the connection. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">writecb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">bev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">nghttp2_session_want_read</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">nghttp2_session_want_write</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">evbuffer_get_length</span><span class="p">(</span><span class="n">bufferevent_get_output</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* eventcb for bufferevent. For the purpose of simplicity and</span>
<span class="cm">   readability of the example program, we omitted the certificate and</span>
<span class="cm">   peer verification. After SSL/TLS handshake is over, initialize</span>
<span class="cm">   nghttp2 library session, and send client connection header. Then</span>
<span class="cm">   send HTTP request. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eventcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">events</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">http2_session_data</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">bufferevent_getfd</span><span class="p">(</span><span class="n">bev</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alpn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alpnlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Connected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">ssl</span> <span class="o">=</span> <span class="n">bufferevent_openssl_get_ssl</span><span class="p">(</span><span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span><span class="p">);</span>

    <span class="n">SSL_get0_next_proto_negotiated</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpnlen</span><span class="p">);</span>
<span class="cp">#if OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">alpn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SSL_get0_alpn_selected</span><span class="p">(</span><span class="n">ssl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpnlen</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// OPENSSL_VERSION_NUMBER &gt;= 0x10002000L</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpn</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">alpnlen</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;h2&quot;</span><span class="p">,</span> <span class="n">alpn</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;h2 is not negotiated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
    <span class="n">initialize_nghttp2_session</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="n">send_client_connection_header</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="n">submit_request</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">session_send</span><span class="p">(</span><span class="n">session_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Disconnected from the remote host&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_ERROR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Network error&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">BEV_EVENT_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">warnx</span><span class="p">(</span><span class="s">&quot;Timeout&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">delete_http2_session_data</span><span class="p">(</span><span class="n">session_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Start connecting to the remote peer |host:port| */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">initiate_connection</span><span class="p">(</span><span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">evbase</span><span class="p">,</span> <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span>
                                <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">bufferevent</span> <span class="o">*</span><span class="n">bev</span><span class="p">;</span>
  <span class="n">SSL</span> <span class="o">*</span><span class="n">ssl</span><span class="p">;</span>

  <span class="n">ssl</span> <span class="o">=</span> <span class="n">create_ssl</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">);</span>
  <span class="n">bev</span> <span class="o">=</span> <span class="n">bufferevent_openssl_socket_new</span><span class="p">(</span>
      <span class="n">evbase</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ssl</span><span class="p">,</span> <span class="n">BUFFEREVENT_SSL_CONNECTING</span><span class="p">,</span>
      <span class="n">BEV_OPT_DEFER_CALLBACKS</span> <span class="o">|</span> <span class="n">BEV_OPT_CLOSE_ON_FREE</span><span class="p">);</span>
  <span class="n">bufferevent_setcb</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">readcb</span><span class="p">,</span> <span class="n">writecb</span><span class="p">,</span> <span class="n">eventcb</span><span class="p">,</span> <span class="n">session_data</span><span class="p">);</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">bufferevent_socket_connect_hostname</span><span class="p">(</span><span class="n">bev</span><span class="p">,</span> <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">dnsbase</span><span class="p">,</span>
                                           <span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not connect to the remote host %s&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">bev</span> <span class="o">=</span> <span class="n">bev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get resource denoted by the |uri|. The debug and error messages are</span>
<span class="cm">   printed in stderr, while the response body is printed in stdout. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">http_parser_url</span> <span class="n">u</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>
  <span class="n">SSL_CTX</span> <span class="o">*</span><span class="n">ssl_ctx</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">evbase</span><span class="p">;</span>
  <span class="n">http2_session_data</span> <span class="o">*</span><span class="n">session_data</span><span class="p">;</span>

  <span class="cm">/* Parse the |uri| and stores its components in |u| */</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">http_parser_parse_url</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">uri</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Could not parse URI %s&quot;</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">host</span> <span class="o">=</span> <span class="n">strndup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uri</span><span class="p">[</span><span class="n">u</span><span class="p">.</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">off</span><span class="p">],</span> <span class="n">u</span><span class="p">.</span><span class="n">field_data</span><span class="p">[</span><span class="n">UF_HOST</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">field_set</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UF_PORT</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">port</span> <span class="o">=</span> <span class="mi">443</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">port</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">ssl_ctx</span> <span class="o">=</span> <span class="n">create_ssl_ctx</span><span class="p">();</span>

  <span class="n">evbase</span> <span class="o">=</span> <span class="n">event_base_new</span><span class="p">();</span>

  <span class="n">session_data</span> <span class="o">=</span> <span class="n">create_http2_session_data</span><span class="p">(</span><span class="n">evbase</span><span class="p">);</span>
  <span class="n">session_data</span><span class="o">-&gt;</span><span class="n">stream_data</span> <span class="o">=</span> <span class="n">create_http2_stream_data</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

  <span class="n">initiate_connection</span><span class="p">(</span><span class="n">evbase</span><span class="p">,</span> <span class="n">ssl_ctx</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">session_data</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
  <span class="n">host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">event_base_loop</span><span class="p">(</span><span class="n">evbase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">event_base_free</span><span class="p">(</span><span class="n">evbase</span><span class="p">);</span>
  <span class="n">SSL_CTX_free</span><span class="p">(</span><span class="n">ssl_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Usage: libevent-client HTTPS_URI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigaction</span><span class="p">));</span>
  <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
  <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">SSL_load_error_strings</span><span class="p">();</span>
  <span class="n">SSL_library_init</span><span class="p">();</span>

  <span class="n">run</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tutorial-server.html" class="btn btn-neutral float-right" title="Tutorial: HTTP/2 server" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="building-android-binary.html" class="btn btn-neutral" title="Building Android binary" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, 2015, 2016, Tatsuhiro Tsujikawa.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.22.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>